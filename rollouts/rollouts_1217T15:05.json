[{"role": "system", "content": "You are a very competent coder.<|im_end|><|im_system|>tool_declare<|im_middle|>[{\"function\":{\"description\":\"Call this tool to submit the solution python code.\",\"name\":\"submit_solution\",\"parameters\":{\"properties\":{\"python_code\":{\"type\":\"str\"}},\"required\":[\"python_code\"],\"type\":\"object\"}},\"type\":\"function\"}]"}, {"role": "user", "content": "Please solve the following programming problem. Please use tool calls to output the solution.\nThe script should read the input with the `input` function and print the output with the `print` function.\nNote that the solution would be run as is, so you must NOT print anything other than the expected output. Namely, do NOT use debug prints and do not write demos.\n\nAn oriented weighted forest is an acyclic weighted digraph in which from each vertex at most one edge goes.\n\nThe root of vertex v of an oriented weighted forest is a vertex from which no edge goes and which can be reached from vertex v moving along the edges of the weighted oriented forest. We denote the root of vertex v as root(v).\n\nThe depth of vertex v is the sum of weights of paths passing from the vertex v to its root. Let's denote the depth of the vertex v as depth(v).\n\nLet's consider the process of constructing a weighted directed forest. Initially, the forest does not contain vertices. Vertices are added sequentially one by one. Overall, there are n performed operations of adding. The i-th (i > 0) adding operation is described by a set of numbers (k,  v1,  x1,  v2,  x2,  ... ,  vk,  xk) and means that we should add vertex number i and k edges to the graph: an edge from vertex root(v1) to vertex i with weight depth(v1) + x1, an edge from vertex root(v2) to vertex i with weight depth(v2) + x2 and so on. If k = 0, then only vertex i is added to the graph, there are no added edges.\n\nYour task is like this: given the operations of adding vertices, calculate the sum of the weights of all edges of the forest, resulting after the application of all defined operations, modulo 1000000007 (109 + 7).\n\n\n\n"}, {"role": "assistant", "content": "<think>We need to solve a programming problem. Let's rewrite the description in more friendly terms. The problem is about constructing a directed weighted forest (acyclic digraph where each vertex has at most one outgoing edge). The forest starts empty (no vertices). There are n operations (i from 1 to n) of adding vertex i. For each i, there is a set of numbers: (k, v1, x1, v2, x2, ..., vk, xk) meaning:\n\n- Add vertex i (the i-th vertex) to the forest.\n- For each j from 1 to k, add a directed edge from root(vj) to i with weight depth(vj) + xj.\n\nNote: It says \"add vertex number i\" and \"k edges\". Actually the description: \"add vertex number i and k edges to the graph: an edge from vertex root(v1) to vertex i with weight depth(v1) + x1, an edge from vertex root(v2) to vertex i with weight depth(v2) + x2 and so on.\"\n\nThus edges always go from the root of some existing vertex v_j to the new vertex i. This ensures the forest property (each vertex has at most one outgoing edge) because edges are directed towards new vertex; root(v) may have already a child; but root(v) may have multiple incoming edges? Actually root(v) may have incoming edges from any number of other vertices. Since root(v) is a root (no outgoing edge), that remains unchanged because edges go from root(v) to new vertex. So root(v) becomes a non-root? Wait root(v) originally has no outgoing edge; after adding edge from root(v) to i, now root(v) now has outgoing edge, so it is no longer a root. But the definition of root(v) might change. Actually they define root( v ) as \"the vertex from which no edge goes and which can be reached from vertex v moving along the edges\". i.e., root(v) is a root of the tree containing v (the unique vertex with out-degree zero reachable from v). After adding a new edge root(v) -> i, root(v) now has an outgoing edge, so it's no longer a root. So root(v) defined earlier may no longer be a root. However the problem statement says \"The i-th (i > 0) adding operation is described by a set of numbers (k, v1, x1, v2, x2, ... , vk, xk) and means that we should add vertex number i and k edges to the graph: an edge from vertex root(v1) to vertex i with weight depth(v1) + x1, an edge from vertex root(v2) to vertex i with weight depth(v2) + x2 and so on.\" This indicates that we need to consider root(v_j) at the moment of adding vertex i, after previous i-1 vertices have been added, i.e., before adding edges of i. So root references the root of v_j in the current forest before adding vertex i.\n\nThus each new vertex i will be a sink (since edges go to i), and it may have multiple incoming edges from various roots; after adding edges, those root vertices become internal nodes with one outgoing edge each (to i). So they are no longer roots. So root(v_j) may not be a root after adding edges. That's fine.\n\nGoal: compute sum of weights of all edges added throughout process, modulo MOD = 1e9+7.\n\nInput format: The description doesn't give explicit format; we need to parse from standard input. Usually in such problems, the input may start with n, then for each i from 1..n, we have a line: first integer k, then k pairs of (v_j, x_j). Or perhaps it's all numbers separated by spaces, not lines. We'll need to be flexible.\n\nEdge weights: weight = depth(v_j) + x_j.\n\nWe need to maintain for each vertex:\n\n- its parent (the outgoing edge from it). Actually each vertex will have at most one outgoing edge (to a newer vertex). Because edges always go from older root to new vertex, so older vertices become internal nodes and may have outgoing edge to a later vertex. After being used as root, root's outgoing edge will be set to the new vertex i; we need to ensure that root hasn't already had an outgoing edge, which it won't because it is root before adding i. After that, it is no longer root.\n\n- depth(v): sum of edge weights along path from v to its root (i.e., the root after all operations). Since each vertex will have at most one outgoing edge, we can compute depth as the sum of weights of edges from v downwards to a root (with out-degree zero). That's like distance to root.\n\n- root(v): the root of tree containing v i.e., the vertex with no outgoing edge reachable from v.\n\nWe need to support queries of root(v) and depth(v) for existing vertices when adding edges for new vertex i. There will be up to n vertices and total edges sum = sum of all k across all i. We need efficient queries.\n\nBounds are not given, but we anticipate n up to maybe 200,000 or 500,000, and total edges maybe up to 200,000 etc. Need O(alpha(n)) per operation using Union-Find style DSU (disjoint set union) with path compression and tracking depth. However the graph is directed: each vertex has exactly one outgoing edge (except roots). So we can treat each vertex as pointing to its parent. Actually each vertex points to its child? Wait edges go from root(v) -> i. So root(v) gets an outgoing edge to i, and i has no outgoing edge initially (or might later get an outgoing edge when a later vertex includes root(i) as source). So each vertex has at most one outgoing edge (child), maybe multiple incoming edges (parents). This is like a reversed tree: typical DSU uses parent pointer to parent (the node you point to). Here each vertex can have at most one outgoing edge; we might represent each vertex's outgoing neighbor. So it's like a functional graph: each vertex points to its child (or null if root). We need to find root(v) (the root of v's tree) which is the vertex reachable by following outgoing edges (child pointers) until reaching a vertex with no outgoing edge. That's opposite of usual DSU parent pointer direction.\n\nThus we have a forest where each node has at most one outgoing edge (to its child). We're adding edges from a root (source) to a new node. The new node becomes a child of that root; root's outgoing edge set to new node. As a result, the root may become a non-root. When we later query root of some older vertex, path may lead to this new child.\n\nThus we need a data structure to answer root and depth queries efficiently. Depth is sum of edge weights on path from node to root (i.e., following outgoing edges). Depth(v) = weight(v->child) + depth(child). For root nodes, depth = 0 (since no outgoing edge). So it's similar to path sum queries.\n\nWe can maintain for each vertex:\n\n- child: initially null (no outgoing edge).\n- weight_to_child: weight of edge to child, only valid if child exists.\n- depth(v) is not stored directly but can be computed via prefix sums: depth_to_root[v] = weight_to_child + depth_to_root[child]; need to compute root and depth quickly.\n\nWe can consider union-find like structure but reversed: When adding edge from root(v_j) (which currently has no child) to new node i with weight w = depth(v_j) + x_j, we set child[root(v_j)] = i and weight[root(v_j)] = w. Node i has no child initially. We also need to maintain for each node its root, i.e., the end of chain (node with no child). Since we always add edges by connecting a leaf (root) to a new node, each node's root changes only when its outgoing edge is added, which occurs at most once. This suggests we can use a DSU where each node initially is its own set representative (its root). When we add edge from a to b (where a is root before addition), we union the sets: a's root becomes b's root? Actually after adding edge a->b, a's root is now b's root (which currently is b because b currently has no outgoing edge). So we can union a and b, with b as the new root of the combined set. This is a union operation where we always attach the root of one set (a, which is a root of its set) under the root of another set (b). But careful: In DSU, each node has a \"parent\" pointer for union-find structure; we can maintain a DSU that tracks for each vertex its \"representative root\" = the current root of its tree (node with no outgoing edge). At start, each vertex is its own root and its own DSU representative. When we add directed edge from a (which must be a root) to b (new vertex), after linking, a is no longer a root; the root of a's set becomes root of b (which is b). So we set parent[a] = b in DSU (like union by making a's representative point to b's representative). In effect, we unify the two sets with b's representative as the new root.\n\nThus we could maintain DSU that gives root for any node: find(v) returns the root node (the node with no outgoing edge) for v.\n\nBut we also need depth(v) = sum of edge weights along edges from v to root. We can maintain a value \"dist_to_root[v]\" = sum of weights from v to root in the current forest. Initially, root = v, dist = 0. When we set a->b with weight w, we have:\n\n- For node a (former root), its child becomes b. So its distance to root becomes w + dist_to_root[b] (where dist_to_root[b] is currently 0 because b is a root). So we can set dist_to_root[a] = w.\n\n- For any node x that had edges pointing (through child chain) to a (i.e., x in the same set as a before addition), their distance to root will also increase by w (since they go through a to b). More generally, after linking a under b, the root of the set changes from a to b, and distance to root for all nodes in a's set will increase by w (since path now includes a->b). So we need to update dist_to_root for all nodes in that set. That could be many nodes.\n\nBut we can avoid updating all nodes by using union-find with path compression and storing \"potential\" or \"distance to parent\" as in typical union-find for weighted graphs (like \"Union-Find with potential differences\").\n\nClassic union-find can maintain for each node parent pointer in DSU (representative of set), and an extra value \"weight\" that represents some measure relative to parent. For typical problems like \"food chain\" or \"weighted union-find\", they maintain for each node the distance to its parent in DSU tree.\n\nIn this scenario, we need to support:\n\n- find(u): returns the root (representative) of the set (with no outgoing edge). Actually DSU's \"representative\" will be the root of the tree, i.e., that node with no outgoing edge for that set. Initially each node is its own representative. When we add edge from a (root) to b (new node), we'll unify sets of a and b (which is just the set containing b) by making a's representative point to b's representative. Since a must be a root (no outgoing edge), it will become a child in DSU tree. So DSU parent of a will become b (or the root of b's set). For nodes in a's set before union, their DSU parent chain eventually leads to a (as representative). After union, they will eventually lead to b (or b's representative). So find(x) will still return the root of the whole component.\n\n- Additionally, we need to compute depth(v) = sum of edge weights along original forest edges from v to root. This can be expressed as the sum of DSU potentials along DSU parent pointers? We must differentiate between DSU parent (for union-find) and child pointer in original forest. Actually we can store for each node u, a value \"dp[u]\" = sum of weights from u to its DSU parent (which is the root of its component after union). But we must be careful: the DSU parent of a node is not necessarily the child pointer direction. Let's define:\n\nWe maintain DSU \"representative\" as the root of the current set (node with no outgoing edge). For each node, we have a \"parent\" pointer in DSU: parent[u] is the next node on the path to the root (representative) in the DSU tree; parent of root is itself. We'll also maintain a value \"diff[u]\" which is sum of edge weights from u to parent[u] following the original forest edges? Wait diff in weighted union-find typically stores the \"potential\" of node relative to parent: e.g., if we have constraints of type weight(u,v) = w, meaning value[u] - value[parent] = w. Here we have depth to root property: depth[u] = weight on edge from u to child + depth[child], etc. But we want to compute depth(u) quickly.\n\nIn union operations, we only add edges where source is a root, connecting to new node. So originally, before addition, the source a is a root: it has no outgoing edge. After addition, a's outgoing edge is set to b with weight w. In terms of depth: depth[a] = w + depth[b], but depth[a] used to be 0 (as a root). After linking, we need to be able to compute depth for any node in the component that previously had root a. Since all nodes in that component will be extended by w (since they must travel through a->b). That is like adding w to all depth values in that component.\n\nWe could maintain for each node its depth to root (distance to root) as a variable. Then when we link a->b with weight w, we need to increase depth of all nodes in component of a by w, and also shift root from a to b. That's like union by making a's root point to b, and accumulating w to the entire component a. We could use a DSU with potential differences where each node stores its depth relative to its parent in DSU tree. If the DSU parent is the next node towards the root (some node that is the \"representative\" after unions), then we can compute depth of any node as the sum of potentials along the DSU parent chain to the root.\n\nLet's think: Represent each component as a tree directed towards the root (node with no outgoing edge). This tree is formed by edges of the original forest reversed? Actually original forest edges go from root to child. So they point downwards: root->...->leaf (leaf being new node). If we want to traverse from a node to the root (to compute depth), we need to follow outgoing edges upward (reverse direction) i.e., from node to child? Wait, original direction is from older root to new node (i.e., root->i). So edges point from older node to newer node (descendant). The root (no outgoing) is the oldest node in the component (with smallest index perhaps). But they define depth(v) as sum along path from v to root following edges (i.e., moving forward along edges? Wait, depth is sum of weights of paths passing from the vertex v to its root. Since edges are directed from root to leaves (like outgoing edges of a root to child), you can go from v to its root moving opposite direction of edges. But they say \"moving along the edges of the weighted oriented forest\". That suggests you follow edges (direction) to go from v to root. However edges go from root to leaf, so moving from leaf to root would be moving upstream against edge direction. This is ambiguous. Let's read carefully:\n\n\"An oriented weighted forest is an acyclic weighted digraph in which from each vertex at most one edge goes. The root of vertex v of an oriented weighted forest is a vertex from which no edge goes and which can be reached from vertex v moving along the edges of the weighted oriented forest. We denote the root of vertex v as root(v). The depth of vertex v is the sum of weights of paths passing from the vertex v to its root. Let's denote the depth of the vertex v as depth(v).\"\n\nThus root is reachable from v by moving along edges (following direction). So edges must be directed from vertex to root? Because we need to follow edges from v to root. For a tree where each vertex has at most one *outgoing* edge, the root has no outgoing edges. Then moving \"along the edges\" following direction from v would go from v to its outgoing neighbor (child), then that node's outgoing neighbor, etc. That leads away from root. So root would not be reachable. So maybe \"from each vertex at most one edge goes\" means indegree <= 1? Actually \"at most one edge goes\" means out-degree <= 1? The phrase \"edge goes\" might mean \"edge goes out of\" the vertex (i.e., outgoing). Usually \"an edge goes from vertex a to vertex b\" is common phrase. So \"at most one edge goes from each vertex\" suggests out-degree <=1.\n\nBut then root defined as vertex from which no edge goes (i.e., out-degree 0) and reachable from v moving along edges. That would be contradictory.\n\nLet's examine orientation typical definitions: In a directed forest, each vertex has at most one incoming edge (i.e., indegree <=1) and the root has indegree 0; edges directed away from root. Then the root is reachable from any vertex by moving along edges (following direction). But they say \"at most one edge goes\" which could mean \"at most one edge incident\" but maybe they meant indegree? The phrase \"an oriented weighted forest is an acyclic weighted digraph in which from each vertex at most one edge goes.\" Actually \"edge goes from vertex a to vertex b\" unambiguous direction. So at most one edge goes from each vertex (out-degree <= 1). Combined with root defined as vertex from which no edge goes (i.e., out-degree 0). For root to be reachable from v via edges, you need to follow edge directions backward, not forward. Example: out-degree <=1, but indegree can be many. So root is a sink (no outgoing). Starting from any node, you follow outgoing edges until you reach sink. That's typical functional graph (each node points to at most one successor). That is also a forest of directed trees where edges point from parent to child? Actually typical rooted tree representation: each node has at most one parent (incoming). Here each node has at most one child (outgoing). That's reversed. In that case, depth(v) measured from v to root (sink) is sum of edge weights along the chain of outgoing edges (like distance to sink). Equivalent to typical depth from node to root if edges reversed direction. Fine.\n\nNow consider operation: adding vertex i and edges from root(v_j) to i with weight depth(v_j) + x_j. If root(v_j) is a sink (no outgoing edges) and we add an edge from root(v_j) to i, now root(v_j) becomes not a sink. It has an outgoing edge to i. So the root of v_j (sink) moves to i (since i currently has no outgoing edges). This matches linking a node (previous sink) to a new sink.\n\nThus the root of a vertex is the sink in its directed path. So in constructing forest, we always connect previous sink nodes to new sink nodes.\n\nHence we need to compute depth(v) = sum of weights from v to sink along outgoing edges. That depth can be computed if we store for each node its outgoings.\n\nWe need to answer queries root(v) and depth(v) while constructing. After processing all operations, we also need sum of weights of all edges added.\n\nWhen adding edges, we need depth(v_j). That is depth of v_j before adding vertex i (and before linking root(v_j) to i). So we need ability to compute depth(v) quickly.\n\nOverall, total sum of edge weights = sum over each added edge weight w = depth(v_j) + x_j.\n\nThus we can just compute each w and accumulate modulo MOD.\n\nThe challenge is computing depth(v) efficiently. Since we need depth(v_j) for each operation. Given constraints maybe up to 10^5 or 10^6, we can process each edge in O(log n) or amortized O(alpha(n)). Weighted union-find can be used.\n\nWe can maintain for each vertex:\n\n- parent_in_outgoing: the vertex it points to (its child) if any, else -1 (null). call child[u].\n- weight_to_child[u]: weight of that edge.\n\nWe also need depth(u) = sum of weights along chain from u following child pointers until reaching a node with child = -1.\n\nThus depth can be computed via recursion with memoization or DP: Since each node's child is set at most once, we can compute depth(u) lazily: after final forest built, we could compute all depths by traversing from each node to root (sink) but we need depth during construction earlier.\n\nBut we can compute depth(u) in a just-in-time manner using union-find with \"path compression\" for the chain of child edges: we can treat child pointers as \"parent\" for a union-find that goes upward (from node towards sink). However each node has only one child pointer (outgoing). That's a singly-linked list structure. If we compress paths, we can compute depth quickly.\n\nStandard approach: For each node we keep a \"representative\" of its set (the sink of chain) using union-find. When we add an edge from a (sink) to b (new node), we union the sets of a and b, with b's sink as new sink. The depth of a becomes w + depth(b) (which is zero). For all nodes in a's component, their depth to new sink will increase by w. So we can maintain for each node its distance to its sink.\n\nWeighted union-find (aka \"potential DSU\") can store for each node the distance to its parent (the next node on path to sink). The DSU parent of a node is the next node after following child pointers repeatedly until reaching the sink? Actually typical DSU for union of directed chains uses the next node as parent after linking.\n\nLet's define:\n\n- Each node initially its own set; DSU parent of node = itself (or itself as root). It is considered the sink.\n\n- When we add edge a -> b with weight w, we set DSU parent of node a to b (the new sink). We'll also store weight_to_parent[a] = w + distance_from_b_to_its_sink (but b's distance is zero as b is a sink). However after further unions, b may become linked to some other node later; then we need to update distances accordingly.\n\nWe need a DSU where we can query for any node v:\n\n- find(v): returns the current sink (representative) of the component.\n\n- dist(v): returns sum of weights along child edges from v to that sink.\n\nWe can implement using typical \"weighted DSU\" (also known as \"Union-Find with potentials\").\n\nStandard weighted DSU uses parent[p] for each node, storing the \"potential difference\" from node to its parent: diff[p] = value[p] - value[parent[p]]. When we need to compute value[x] relative to root, we compute sum of diff along path. For root, parent[root] = root, diff = 0.\n\nIn our scenario, we want \"depth(v)\" = sum of edge weights from v to sink (representative). Let's define a potential value \"pot[v]\" = depth(v). depth(v) is sum of edge weights from v to current sink. For a root (sink), depth = 0.\n\nWhen we add edge a -> b with weight w (depth(a)=? depth(b)=?), we are linking a (currently sink) under b (currently sink). After linking, depth of a becomes w + depth(b) (but depth(b) = 0). For any node x in the component of a, depth(x) increases by w (since they must travel through a->b). In terms of potentials, we can set parent[a] = b, and set diff[a] = w + depth(b). But depth(b) is zero currently; but after future unions b may get a parent; depth(b) might become non-zero later (when a later edge from b's sink to new node added). Since we store diff relative to parent (which may change), we need to maintain correct values after future unions.\n\nClassic solution: use DSU with union by rank and path compression where we maintain diff to parent (the weight from node to its parent in terms of depth). The \"value\" of a node is its depth to root of DSU tree (i.e., sink). find(x) returns root (representative) and also compresses path updating diff[x] to be sum of diffs to root.\n\nSpecifically:\n\n- parent[x] = root of DSU set (the root of union-find tree), not necessarily the sink in original forest. Actually in weighted DSU, parent[x] is the parent in union-find tree (which could be the next node on sink path). But we can treat each sink as the root of DSU set. Then when we link a (sink) to b (sink), we set parent[a] = b, diff[a] = w + dist(b). But dist(b) = 0 (its depth). However after b later gets a parent, then the diff values will be correct because they use relative differences.\n\nWe need to define depth(x) as sum of edge weights from x to its current sink (i.e., following child pointers). For nodes a and b that we link via a->b, the depth of any node x in a's component will become depth_original(x) + w + depth(b) (which is zero). Since depth_original(a) = 0 (sink). After linking, depth(a) = w. depth(x) (descendant of a) = depth_original(x) + w. Let's confirm: Suppose before linking, we had a chain: x -> ... -> a (a as sink). Depth(x) originally = sum of edges from x to a. After linking a->b (with weight w), new depth(x) = sum edges from x to a + w + depth(b). Same as old depth(x) + w.\n\nThus we need to support queries of depth(v) and root(v) (the sink). Weighted DSU can handle it: root(v) = find(v). depth(v) = diff_to_root(v) (i.e., sum of diffs along compressed path).\n\nIf we implement DSU with parent array p[] and weight array diff[] where diff[x] stores weight from x to its parent (when p[x] != x). When we compress path, we update diff[x] accordingly.\n\nSpecifically:\n\n- Initially p[x] = x, diff[x] = 0.\n\n- find(x) returns root = find(p[x]) recursively, and updates diff[x] += diff[p[x]] then sets p[x] = root.\n\nIn weighted DSU typical implementation, path compression updates diff to become relative to root.\n\nThus we can compute depth(x) as diff[x] after find(x) (since p[x] = root, diff[x] is weight from x to root). But careful: In weighted DSU, diff[x] is defined as weight(x) - weight(parent[x]), where weight(x) is some potential. In our case, we want depth(x) = sum of edge weights to sink. We'll define weight(x) = depth(x). Then diff[x] = depth(x) - depth(parent[x]).\n\nIf root has depth 0. When we link a -> b with weight w, we need to set parent[a] = b and diff[a] = w (since depth(a) = w + depth(b) and depth(b) = 0). Indeed diff[a] = depth(a) - depth(b) = w.\n\nIf later we link b->c with weight w2, we set parent[b] = c, diff[b] = w2 (since depth(b) = w2 + depth(c)). When we do find(a) later, path compression will sum diff values: diff[a] = w + diff[b] = w + w2; diff[b] = w2 (if still parent = c). So depth(a) = diff[a] = w + w2 = correct.\n\nThus linking two components by attaching one root to another with weight w works fine using DSU union.\n\nBut we must ensure that we only link a root (sink) to another root (sink). That's guaranteed by the operation: for each pair (v_j, x_j), we take root(v_j) (sink) and add edge from that sink to new vertex i with weight depth(v_j) + x_j. So we add edges (a = root(v_j)) -> i with weight w = depth(v_j) + x_j.\n\nThus a was (before operation) a sink; i is new vertex, initially sink, with no outgoing edges. So after adding edges from possibly multiple a's (distinct roots?) Actually note: Several v_j may have the same root? Could be duplicates. Since root(v_j) is sink, and multiple v_j can have same root because there can be multiple nodes that share same root (i.e., belong to same tree). That means we might add multiple edges from the same source root to i? Is that allowed? The operation says we add k edges: an edge from root(v1) to i, an edge from root(v2) to i, etc. There's no restriction that root(v1) can't be the same as root(v2). So we could add multiple parallel edges from same source to same target, each with possibly different weight because x varies and depth(v) may be same if depth(v) same for each v but maybe v's depths differ. However after we add the first edge from a root to i, that root is no longer a sink; thus its status changes. However the operation description seems to treat each edge addition as being based on the graph state before the operation (the i-th adding operation). It may be ambiguous: Are the edges added sequentially within the operation, such that later edges in the same set see the graph after previous edges added? Or are all edges based on the state before the whole operation? It says \"the i-th (i > 0) adding operation is described by a set of numbers (k, v1, x1, v2, x2, ... , vk, xk) and means that we should add vertex number i and k edges to the graph: an edge from vertex root(v1) to vertex i with weight depth(v1) + x1, an edge from vertex root(v2) to vertex i with weight depth(v2) + x2 and so on.\" It reads like we calculate root(vj) and depth(vj) based on the state before the whole operation (i.e., before adding vertex i and any of those k edges). Because they say \"add vertex number i and k edges to the graph\". So all edges are added after vertex i is added (which initially has no outgoing edges). The edges go from root(vj) (which are roots from previous forest) to new vertex i. Since all edges originate from distinct root(vj) which are roots in the forest before adding i, after adding the first edge, that root becomes non-root; but root(vj) for subsequent j might refer to the same vertex which may not be a root right now. However the phrase \"root(v2)\" maybe recomputed after adding the first edge? The description does not specify, but typical problems define that all roots are computed before adding any edges of this operation. To avoid ambiguity, we need to see test examples or typical tasks. Since they didn't provide examples, we must deduce logically.\n\nOne must also consider: when you add vertex i, you also add edges from the roots of some existing vertices (v_j) to i. If some v_j share same root, you are effectively adding multiple parallel edges between that root and i. That would create a multigraph with parallel edges (but still forest? Actually then root would have multiple outgoing edges to same child i, violating \"each vertex at most one edge goes\". Since root would have >1 outgoing edges to i (parallel edges). However they said forest property: \"at most one edge goes\" from each vertex (i.e., out-degree \u2264 1). Adding multiple edges from same source would break this condition. So they must assume that for each operation, the roots of the v_j are distinct. Or they treat edges as added sequentially, and after the first edge, root changes and subsequent edges are from new root? But they refer to root(v2) which may be root of v2 after previous edge addition, which could be i? Yet they said \"edge from vertex root(v2) to vertex i\". If root(v2) changes, maybe it could be i? That seems nonsense.\n\nTherefore it's likely they guarantee that the root(v_j) values are all distinct for each operation, ensuring out-degree \u2264 1. Or they consider that edges are added sequentially, but root(v_j) is evaluated after previous edges of same operation are added. Let's analyze both possibilities.\n\nOption A: The roots are computed before adding edges of the operation. Then multiple v_j may share the same root; we would attempt to add multiple edges from that root to i, causing out-degree >1. That would violate constraints. Therefore to avoid this, test data must ensure that for each operation, each root(v_j) is distinct. This seems plausible.\n\nOption B: The roots are computed sequentially, i.e., after each added edge, root neighborhoods may change, thus each edge addition may cause the root of the next v_j to be possibly i (if v_j is in the same component as i after earlier edge), but then edge from root(v_j) to i would be a self-loop? That seems strange.\n\nOption C: In each operation, after adding vertex i, they add k edges from root(v_j) to i based on the current forest state (which includes edges added earlier in the same operation). The set of v_j could be any vertices, but they have distinct roots after each edge is added because after you add an edge from root(v_1) to i, root(v_1) becomes internal node (no longer root). If v_2 had same root as v_1 before operation, after the first edge, root(v_2) is now i because the path leads to i (since root(v_2) = root(v_1) originally but root(v_1) is not root any more). So the second edge would be from i to i? Actually root(v_2) after first edge becomes i (the new sink). That would be adding edge from i to i (self-loop) which violates constraints. So it's unlikely they intend such dynamic modifications.\n\nThus I think the intended interpretation is that root and depth values for each v_j are determined based on the forest before adding vertex i (i.e., the state after previous i-1 vertices have been added). That ensures all root(v_j) are distinct for each operation, otherwise you'd break forest property. So tests will guarantee that.\n\nThus algorithm: For each operation i (1-indexed), read k and then k pairs (v_j, x_j). For each pair, compute root_v = find(v_j) (the current root before adding i). Compute depth_v = depth[ root_v? Actually we need depth of v_j as defined: depth(v_j) = sum of weights from v_j to its root. Weighted DSU find operation returns root and we can compute depth(v_j) as distance_to_root(v_j) (i.e., sum diff from v_j to root). That's typical: depth(v) = dist_to_root(v), where sink is root. So we need a function get_depth(v) that returns diff_to_root(v) (the sum of diff values along DSU parent chain). We'll implement a find(v) that returns root and also compresses path, updating diff. Depth can be computed as diff[v] after find(v). Or we can have a method that returns depth(v) on the fly.\n\nThus we get w = depth_v + x_j.\n\nAdd this w to total sum (mod M).\n\nThen after processing all pairs for vertex i, we need to incorporate edges into DSU. Actually for each pair, we add edge root(v_j) -> i with weight w; note that root(v_j) currently is a sink (its child is null). But we must attach root(v_j) under i.\n\nHowever note that multiple edges can be added from distinct roots to same i. Since each root is distinct, each edge attaches a different root under i. Since i is a sink (no outgoing edge yet), after first edge, i may become a non-root? Actually after we attach root(v_j) -> i, root(v_j) becomes not a sink; i remains sink still (i currently has still no outgoing edge). But i can have multiple incoming edges (multiple roots can point to i). That's allowed: i's indegree may be many, outdegree 0. So after adding all k edges, i remains a sink (no outgoing). So we will have k roots that now have outgoing edge to i (child = i). i's DSU representation is itself (still root of its set). It's possible that after multiple unions, i may not be its own set's representative? Actually each root(v_j) is attached to i (i is the new root of the merged set). The DSU's root of the merged component should be i (since i has no outgoing edge). So we unify each root's set with i's set: we attach root's set under i using union operation.\n\nThus after processing each pair, we need to union root_v (sink) with i (new vertex) with weight w.\n\nBut careful: what if k > 1? i is same for each edge. After first union, root of root_v's set becomes i (the DSU root). For next root_v2 (distinct root) we also need to attach its component to i, making i the root of whole combined set. However we must ensure that after union, i remains root (sink) and the diff values for each root_v are properly set to w_j (so depth of each root_v to new sink is w_j). However for nodes deeper in those components, their depth"}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "<think>The user says \"You did not format your response correctly. Please use a single tool call to submit the solution.\" So they expect a single tool call with the solution code, using the submit_solution function.\n\nThus we need to output a final answer with a single tool call including Python code that reads from stdin and prints result.\n\nWe should produce a solution that solves the problem: reading n and operations, building oriented forest, computing sum of edge weights modulo 1e9+7.\n\nWe need to produce a complete solution.\n\nLet's review all details and design algorithm more thoroughly. Also consider potential pitfalls.\n\n**Understanding the Problem**\n\nWe need to compute sum of edge weights added during constructing oriented weighted forest via operations.\n\n\"n performed operations of adding vertices. Initially forest empty. The i-th operation (i > 0) described by a set of numbers (k, v1, x1, v2, x2, ..., vk, xk) means we add vertex number i and k edges to the graph: an edge from vertex root(v1) to vertex i with weight depth(v1) + x1, an edge from vertex root(v2) to vertex i with weight depth(v2) + x2, and so on. If k = 0, only vertex i is added.\n\nGoal: sum of weights of all edges of forest after all operations, modulo 1e9+7.\n\n**Interpretation**\n\nWe need to parse the operations. Input format is not explicitly given. Usually the format is:\n\n- First line integer n (number of operations).\n- Then for i from 1..n: line starts with integer k_i, then k_i pairs of integers v_j, x_j.\n\nThey may be separated across multiple lines; but we can simply read all ints from stdin and process sequentially.\n\nEdge weights: w = depth(root(v))? Wait \"weight = depth(v_j) + x_j\". The root of v_j is used as the source node, but the weight includes depth of v_j (original vertex, not root). So we need depth of original vertex v_j.\n\nThus we must compute depth(v) for any existing vertex v at each step (prior to adding i). depth(v) is sum of weights of edges on path from v to its root (sink). Equivalent to distance from v to sink in the directed forest direction (following outgoing edges). Since each node has at most one outgoing edge, that is a simple path.\n\nNeed to track depths and roots for nodes up to n.\n\n**Constraints**\n\nNo specific constraints given. We need to handle up to maybe 200k or 500k or even 1e6. Use O(n + total edges) solution.\n\n**Key operations**\n\nFor vertex i added:\n\n- Initially, node i is a new sink (no outgoing edges).\n- For each pair (v, x):\n\n    - Find root r = root(v) (the sink of component containing v).\n    - Find depth d = depth(v) (sum of edge weights from v to r).\n    - Edge weight w = d + x.\n    - Add w to total sum (mod).\n    - Union r with i: attach r under i as new edge with weight w. That means we set parent_in_union_find for r to i, diff[r] = w.\n\nBut careful: The union must reflect that r now has outgoing edge to i (child) with weight w. But the union find must be oriented from node to sink. How to update DSU?\n\nWe have DSU that tracks for each node its \"parent\" pointer towards the sink (i.e., the next node along path to sink). This is analogous to union find of functional graph but reversed direction.\n\nBut Weighted DSU typically works with some potential difference. That fits: The forest is a set of chains (since each vertex has at most one outgoing edge). Each component is a directed tree (like each node has one outgoing edge to its parent?) Actually it's reversed: each node has at most one outgoing edge; that leads to a sink and the graph is acyclic. This functional graph forms a set of directed trees where edges point from node to child (i.e., out-degree 1). But each node may have multiple incoming edges (like multiple nodes point to same child). However each component can have many nodes but only one sink (node with out-degree 0). Because there is at most one sink per component (like directed forest). Since out-degree \u22641, each component forms a directed tree where edges go from parent to child but reversed typical parent->child direction but they point \"downwards\" towards leaves. But the direction is away from root (source) towards sink (think of a tree where each node points to its unique child on path to the sink). This is like each node selects one outgoing neighbor; so the structure is a \"forest of directed path unions\"? But with indegree possibly >1, you can have branching: Example: node a (sink) has two incoming edges from b and c (both point to a as child). b and c have outgoing edge to a. a's out-degree = 0. b and c each have out-degree =1, incoming maybe from other nodes etc. This structure is like reversed rooted tree: The sink is root (like actual root) if you consider reversed direction of edges (i.e., edges point from child to parent). But we can treat each node's outgoing edge as a \"next pointer\" towards sink.\n\nThus for depth(v), we need to sum edge weights of edges along this directed path from v to sink.\n\nSince edges are added only from a sink to a new node. The new node initially has no outgoing edge, thus is a sink. So the edge direction is from previous sink to new sink.\n\nThus each edge adds weight w from the previous sink to new sink.\n\nHence, depth of previous sink after linking becomes w (distance to new sink). Depth of any node above previous sink (i.e., nodes that previously pointed to that sink) will increase by w because they travel through this new edge. That's exactly the union operation: we are merging two components, where the sink of one component (previous sink) becomes a non-sink, attaches to the sink of the other component (the new node i) which remains sink.\n\nIf there are multiple roots attached to i, each of those root components merges into i's component, but after first union, the component containing i will have a sink i (still). If we attach another root r2 to i, r2's component merges into i's component, with r2's depth to sink = w2; i continues as sink.\n\nThus DSU can handle successive unions of many roots into same sink.\n\nThus algorithm: maintain DSU with potential differences.\n\n**Weighted DSU Approach**\n\nWe need a DSU such that for any node v, after processing operations, we can query:\n\n- find(v): returns the current sink of component (representative). (We need also path compression)\n- depth(v): sum of edge weights from v to sink. Represented by some potential \"dist[v]\" which is difference between depth(v) and depth(parent[v]).\n\nImplementation details:\n\nWe'll have arrays parent[] (size n+1) where parent[x] = the next node towards sink in DSU tree. Initially parent[x] = x (makes x its own set representative). We'll also have weight[] (or diff[]) storing weight from x to parent[x] (i.e., depth(x) - depth(parent[x])).\n\nWhen we compress path, we need to update parent[x] to root and weight[x] to sum of weights along original path.\n\nWe must also handle large n up to maybe 1e6, recursion depth could be large; we may do iterative find.\n\nPseudo:\n\ndef find(x):\n    if parent[x] != x:\n        orig_parent = parent[x]\n        parent[x] = find(parent[x]) # recursively find root\n        weight[x] = (weight[x] + weight[orig_parent]) % MOD\n    return parent[x]\n\nBut careful with recursion depth. Use while loops or recursion with sys.setrecursionlimit.\n\nAlternatively we can implement iterative path compression:\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    # compute total weight to root\n    root = x\n    acc = 0\n    while parent[root] != root:\n        acc = (acc + weight[root]) % MOD\n        root = parent[root]\n    # Now root is root; compress path\n    # Actually we need to set parent for each visited node to root and update weight accordingly.\n    # Let's collect nodes in path.\n    # Another approach: recursion is simpler.\n\nGiven n up to maybe 2e5 or 1e6, recursion may be okay if we set recursionlimit high, but Python recursion may still be slower. We'll use iterative with stack.\n\nBut we also need to get depth(v) i.e., sum of weights from v to root. We'll get that after find(v) because weight[v] will hold the sum to root (since we compress). Or we could have separate function depth(v) that calls find(v) and then returns weight[v].\n\nImplementation details for DSU:\n\n- parent[i] = i initially.\n- weight[i] = 0 initially.\n\nWhen we union two components: we have a root r (source, a sink before union) and new node i (sink). The edge weight is w (which is depth(v) + x). The effect: we set parent[root] = i, weight[root] = w (plus maybe depth(i) which is 0). However we need to be careful: After find(root) we know its root is itself. After linking, its root becomes i, which is still root (maybe with other nodes attached). In DSU, we cannot have parent[i]=i and also have i might be attached to something else later. But we can just set parent[root] = i, weight[root] = w.\n\nBut there's nuance: suppose i already had edges from previous roots attached (previous in same operation). After first union, i becomes representative for its component. After second union (another root r2) we want to merge r2's component into i's component: we set parent[find(r2)] = i, weight[find(r2)] = w2.\n\nYes, find(r2) will be r2 (since it's a sink). So union is just parent[r2] = i, weight[r2] = w2.\n\nThus no union-by-rank needed because we always attach one root to another sink; there is no cycle.\n\nBut after many operations, i could later be attached to a later vertex j in a later operation. That's fine: At some later step, we will have an operation where some v_j refers to some node maybe in i's component. We compute its root and depth accordingly.\n\n**Processing Input**\n\nWe'll read all ints from stdin via sys.stdin.buffer.read().split()\n\nThe first integer is n. Then we iterate i from 1 to n.\n\nBut the tricky part: For each i, we need to read k_i (the number of pairs). Then read k_i pairs (v, x). However there may be any number of whitespaces and newlines, so we can treat it as a sequential stream: after reading n, we parse operations sequentially.\n\nPseudo:\n\ndata = list(map(int, sys.stdin.buffer.read().split()))\nit = iter(data)\nn = next(it)\ntotal_sum = 0\nMOD = 1000000007\n\ninitialize parent and weight arrays of size n+1.\n\nfor i in range(1, n+1):\n    parent[i] = i\n    weight[i] = 0\n\nNow for each i:\n\nk = next(it)\nfor _ in range(k):\n    v = next(it)\n    x = next(it)\n    # compute depth of v\n    # find root of v (which is root of its component)\n    # we need depth of v: we can call find(v) to compress path; but after find(v), weight[v] will contain distance to root. However careful: find(v) compresses path and updates weight[v]. But weight[v] may also be used later for other queries? Depth of v may change after later unions (like when its component attaches to new sink). Our DSU representation ensures that after path compression, weight[v] holds sum to current root (the sink). So calling find(v) each time is safe: we get root as parent[v] after compression; weight[v] is depth(v). However after later attachments (like linking sink to new vertex), weight values of nodes above sink may become outdated? Let's examine.\n\nOur DSU weight[x] stores distance from x to its parent in DSU tree (which is next node towards sink). After path compression, weight[x] stores total distance to root. However after we link parent (sink) to new vertex i, we change parent of that sink to i and weight of that sink to w. That extends the path for all nodes in that component. For nodes that already had weight to root (sink) as some d, they will now have weight to new root as d + w, but we don't update them directly. However they will get the new depth after we call find(x) again: since parent[x] is still the old sink (now intermediate), but after find, we will compress path and sum weight[x] + weight[old_sink] (which becomes d + w). Because weight[old_sink] is w, the edge to i. So our DSU representation works.\n\nThus we can compute depth(v) as weight[v] after find(v) (ensuring path compression). However need to ensure weight values are modulo MOD maybe; depth values can be large; each weight may sum many edges. Since we need to compute w = depth(v) + x (mod MOD), we may need to compute depth(v) modulo MOD. However the actual weight w may exceed MOD but we want final sum modulo MOD. Since edge weight can be up to maybe large values (x up to large). We'll incorporate mod in weight sums.\n\nPotential risk: weight[v] after find(v) returns a value modulo MOD. That's okay: the sum of weights we want for final answer is taken modulo MOD. However we need depth(v) modulo MOD to compute w modulo MOD. That's consistent. However we must be careful: If we store weight[v] modulo MOD, then adding w = ((depth(v) + x) % MOD) we also need to store weight for new edge as w modulo MOD. But actual weight may be larger; but final sum modulo MOD only needs mod sums. That is consistent as long as we compute everything modulo MOD. However may cause issues if depth differences used for something else? The weight is only used for future depth calculations. Since depth is sum of edge weights, and we always compute modulo, the final answer is modulo sum. So we can safely store everything modulo MOD. The only nuance is if we need to compute depth(v) + x modulo MOD. That's fine.\n\nAlternative approach: Use Python integers (big) and only take modulo at the sum step. Could cause overflow for massive n (like 10^5 edges each weight large). Python's arbitrary precision can handle but slower. However it's okay. Usually mod is required for final sum; we can compute everything modulo MOD.\n\nThus we can store weight values modulo MOD.\n\nImplementation details: The find function returns root id, updates weight[x] to sum of weight along path modulo MOD.\n\nImplementation details of find with path compression:\n\ndef find(x):\n    if parent[x] != x:\n        orig = parent[x]\n        root = find(orig)\n        weight[x] = (weight[x] + weight[orig]) % MOD\n        parent[x] = root\n    return parent[x]\n\nWorks because weight[x] is defined as distance from x to parent[x] (depth difference). After recursion, weight[orig] becomes distance from orig to root. So weight[x] = weight[x] (old distance to orig) + weight[orig] (distance from orig to root) = distance from x to root.\n\nNow depth(v) can be obtained as weight[v] after find(v) (since parent[v] = root). However after find(v), parent[v] may not be root if we didn't compress all ancestors? Actually find ensures parent[v] = root after call. So weight[v] becomes sum to root.\n\nBut we must also handle multiple queries for depth of same node many times; DSU weight remains correct after further unions because weight[v] is distance to its parent (some node perhaps not root). After union of its parent (sink) to new vertex, parent of that sink changes, but parent of v remains unchanged; weight[v] remains distance to that old sink. So after union, depth(v) becomes weight[v] + w (weight on new edge). This will be captured next time we compute find(v) again (compress path).\n\nThus algorithm is correct.\n\nComplexities: Each operation includes a find (depth) for each edge (v_j), plus a union (setting parent of root to i). This is O(k * \u03b1(n)). With path compression recursion depth maybe high but we can increase recursionlimit.\n\nAlternatively implement iterative find. But recursion may be okay for n up to 10^5 or 10^6 if recursionlimit high.\n\nTesting: Example (none given).\n\nLet's design small example to verify:\n\nSuppose n=3.\nOperations:\ni=1: k=0 (no edges)\ni=2: k=1: v1=1, x1=5\ni=3: k=1: v1=2, x1=3\n\nCompute manually.\n\nInitially no vertices. But operation 1 adds vertex 1, no edges. So after op1: forest has vertex 1, sink, depth(1)=0, root(1)=1.\n\nOperation 2: add vertex 2, add edge from root(1) to 2 with weight depth(1)+5 = 0+5=5.\n\nNow we have edge 1->2 weight 5. Vertex 2 is sink, depth(2)=0, root(2)=2. Depth(1) = weight from 1 to its root (2) = 5.\n\nSum of edges weights: 5.\n\nOperation3: add vertex3, add edge from root(2) to 3 with weight depth(2)+3 = 0+3=3.\n\nNow edge 2->3 weight 3. Total sum = 5+3 = 8.\n\nNow compute with algorithm: We'll implement DSU.\n\n- Initially parent[1]=1, weight[1]=0.\n- i=2: v=1, x=5.\n   find(1): parent[1]==1 => root=1, weight[1]=0.\n   depth(v) = weight[1] = 0.\n   w = 0 + 5 = 5.\n   total_sum = 5.\n   union: parent[root_v] = i (2), weight[root_v] = w. So parent[1]=2, weight[1]=5.\n   Also need to initialize parent[2]=2, weight[2]=0.\n- i=3: v=2, x=3.\n   find(2): parent[2]==2 => root=2.\n   weight[2]=0 => depth(v) = 0.\n   w = 0+3 =3.\n   total_sum = 8.\n   union: root_v = 2; parent[2]=3, weight[2]=3.\n\nNow total edges weight sum = 8. After all, we can compute depths using DSU.\n\nCheck depth(2) after union: find(2) => parent[2]=3, weight[2]=3, parent[3]=3 => root=3, weight[2] = (weight[2] + weight[3]) = 3+0 = 3 => depth(2)=3. That's correct: path 2->3 weight 3.\n\nDepth(1) after: find(1): parent[1]=2, weight[1]=5. Recursively find root(2). find(2) as before root=3 weight[2]=3 => weight[1] = (5 + weight[2]) = 8; parent[1]=3 => depth(1)=8: sum of edges 1->2 (5) + 2->3 (3) = 8. Good.\n\nOK.\n\nNow scenario with multiple roots attached to same new vertex i. Example:\n\nn=3\n\nOp1: i=1: k=0\n\nOp2: i=2: k=0 (no edges) => vertex2 added but nothing else; both vertices separate.\n\nOp3: i=3: k=2: v1=1, x1=10; v2=2, x2=20.\n\nGoal: compute edges: root(1) = 1, depth(1)=0, weight1 = 0+10 =10 (edge 1->3). root(2)=2, depth(2)=0, weight2 = 0+20=20 (edge 2->3). The forest after operation: two edges from 1 and 2 to 3. Vertex3 is sink. Out-degree of 1 and 2 each =1, they point to same sink 3. That's allowed? They have out-degree 1 each, but they share same child. The condition \"at most one edge goes\" from each vertex is satisfied (since each has at most one outgoing edge). So forest is okay.\n\nNow sum = 10+20=30.\n\nWill algorithm handle?\n\nProcessing:\n\ni=1: parent[1]=1 weight[1]=0\n\ni=2: parent[2]=2 weight[2]=0\n\ni=3:\n\nInitialize parent[3]=3 weight[3]=0.\n\nRead k=2.\n\nFirst pair: v=1, x=10:\n\n- find(1): root=1, depth=0.\n- w=10. total_sum+=10.\n- union: parent[1]=3, weight[1]=10.\n\nNow parent[1]=3, weight[1]=10.\n\nSecond pair: v=2, x=20:\n\n- find(2): root=2 => depth=0.\n- w=20, total_sum+=20 => total_sum=30.\n- union: parent[2]=3, weight[2]=20.\n\nNow parent[2]=3, weight[2]=20.\n\nAll good. Node3 remains root of component (since parent[3]=3). Depth(1): find(1) => parent[1]=3, weight[1]=10 -> root=3 weight[1]=10 => depth=10. depth(2)=20.\n\nThus DSU works.\n\nNow scenario where v is not root (depth>0) and root of v will be determined.\n\nExample: simple chain of 1->2->3.\n\nSuppose after op3 we add vertex4 connecting to v=1 (which is not a root). Let's compute.\n\nContinue after previous example, we have edges 1->3 weight 10 and 2->3 weight20? Actually after previous example we have edges from 1 and 2 to 3. Let's continue building a chain: we have vertex4 added, and we attach to root(1) (which is 3?). Let's compute: v=1: root(1) is vertex 3 (the sink). depth(1) is 10 (Edge 1->3). So root(1) = 3. So we add edge from 3 to 4 with weight depth(1)+x = 10 + x.\n\nThus after adding, root (3) becomes internal node with edge to 4.\n\nOur DSU must handle case where find(v) returns root, but depth(v) is not zero.\n\nExample: x=5, then w = 10+5 = 15. So edge 3->4 weight 15.\n\nNow after adding, we need to union root_of_v (which is 3) with i=4, weight w=15.\n\nIn DSU, after earlier steps, parent[1]=3 weight[1]=10; parent[2]=3 weight[2]=20; parent[3]=3 weight[3]=0.\n\nNow processing i=4:\n\n- We read v=1, x=5.\n\nStep: find(1) will root to 3 and weight[1] = weight[1] + weight[3] = 10+0 = 10; parent[1]=3.\n\nNow depth(1) = weight[1] (since root is 3). So depth =10.\n\n- w = 10 + 5 = 15. total_sum += 15.\n\n- root_of_v = find(v) = find(1) which returns root=3. Need to union root=3 with i=4.\n\nNow we set parent[3] = 4, weight[3] = w.\n\nBut note: In DSU we also need to ensure that for node 3, previously parent[3] = 3 (as root). Now we change parent[3] = 4. Good.\n\nNow after union, we need to adjust weight of node 3's parent: weight[3] = w = 15.\n\nNow after operation, weight[3] = 15, parent[3] = 4.\n\nNow what about node 1 and 2? Their parent remains 3 (which is now an internal node). The DSU structure ensures depth(1) is still computed correctly: find(1) will trace parent[1]=3->4 and sum weight[1] (which is 10) + weight[3] (which is 15) after path compression to get total weight = 25 (10+15). That equals sum edges 1->3 (10) + 3->4 (15) = 25.\n\nWorks.\n\nThus DSU approach works nicely.\n\nNow we need to careful about modulo. We'll store weight values modulo MOD. Since depth values are needed only modulo MOD for weight computations, but w = depth(v) + x (mod M). However x may be large (not modulo). Consider x may be up to large (maybe 10^9). We should compute w = (depth(v) + x) % MOD perhaps, but depth(v) computed mod M may not reflect the true depth value (if we care about correctness of root depth increments). However we only need to compute total sum modulo M. If we compute w modulo M, we may lose real magnitude but total sum modulo M of all w's is sum_i (depth_i + x_i) modulo M. Since depth_i is sum of earlier w's. If we reduce each w modulo M before storing, then later depth values will be computed modulo M too (i.e., subsequent depths are computed modulo M). The final sum modulo M should still match sum of w_i mod M irrespective of whether we propagate full integers or modded values. Because addition modulo M is transitive: (a+b) mod M = ((a mod M) + (b mod M)) mod M.\n\nThus we can store weight values and total sum always modulo M. No overflow or accuracy issues.\n\nNow we need to ensure handling negative numbers? Problem didn't mention negative x or weights; but x could be negative? Possibly. Weighted forest with any integer weight maybe. If x can be negative, we still need mod handling. We'll assume x can be any integer (maybe negative). In Python, x % MOD yields non-negative remainder. We'll need to compute w = (depth + x) % MOD.\n\nMake sure to mod after addition with x possibly negative. Use w = (depth + x) % MOD.\n\nNow need to compute depth(v) after find; we will ensure weight[v] is stored modulo MOD.\n\nThus algorithm:\n\nRead ints:\n\ndata = list(map(int, sys.stdin.buffer.read().split()))\nptr = 0\nn = data[ptr]; ptr+=1\n\nInitialize parent array of length n+1 (1-indexed) = [i for i in range(n+1)].\nInitialize weight (or dist) array of length n+1 = [0]*(n+1).\n\ntotal = 0\nMOD = 1000000007\n\nfor i in range(1, n+1):\n    parent[i] = i\n    weight[i] = 0\n\nFor each i from 1 to n:\n    k = data[ptr]; ptr+=1\n    for _ in range(k):\n        v = data[ptr]; ptr+=2? Actually after k we have pairs of (v,x). So we need to read v and x.\n        x = data[ptr+1]?\n        Actually correct iteration: after reading k, we need to read k*2 numbers: v1, x1, v2, x2...\n        So for j in range(k):\n            v = data[ptr]; x = data[ptr+1]; ptr += 2\n        # process each pair\n\nThus the loop accordingly.\n\nEdge Cases: Input may have k=0, then no pairs.\n\nNow we need to process each pair:\n\ndef find(x):\n    while parent[x] != x:\n        # path compression with recursion\n        # We'll implement recursion for simplicity\n    return parent[x]\n\nBut we need to also compute depth(v). Since we use recursion, we also need to compute weight to root.\n\nOur find returns root. We need depth after find. Implementation using recursion:\n\ndef find(x):\n    if parent[x] != x:\n        p = parent[x]\n        root = find(p)\n        weight[x] = (weight[x] + weight[p]) % MOD\n        parent[x] = root\n    return parent[x]\n\nBut we need to be careful: weight[x] is the distance from x to its parent (previous). After recursion, parent[x] may become root. Adding weight[x] + weight[p] may sum to produce weight[x] to root. But weight[x] already is distance from x to p; and weight[p] after find is distance from p to root; thus weight[x] becomes distance from x to root.\n\nNow after find(v), depth(v) = weight[v] (since parent[v] is root). So w = (weight[v] + x) % MOD.\n\nNow find root(v) simply find(v) returns the root (sink). So root = find(v). Then we union root with i: set parent[root] = i, weight[root] = w.\n\nPotential issue: If we call find(v) for both depth and root, we will call find(v) twice; after first call, weight[v] updated, parent[v] = root. Depth = weight[v] now correct. Then calling find(v) again will just return root, weight[v] unchanged. That's okay.\n\nBut careful: For each pair, we also need root = find(v). But we already called find(v) to compute depth; we can reuse root = find(v) after that, because after calling find(v), parent[v] = root (the sink). So root = parent[v] (or find(v) returns root). So we can store root = find(v) after we compute depth.\n\nImplementation steps per pair:\n\n# find v (computes depth and compresses)\nroot_v = find(v)\ndepth_v = weight[v]  # because parent[v] is root_v.\nw = (depth_v + x) % MOD\ntotal = (total + w) % MOD\n\n# union: attach root_v to i\nparent[root_v] = i\nweight[root_v] = w\n\nNow we need to make sure that weight[i] is zero (since i is sink with no outgoing edges). When we later do find(i) for later operations, weight[i] should represent distance from i to its parent (sink). Initially parent[i]=i, weight[i]=0.\n\nNow after attaching root_v to i, weight[i] remains 0 (i may become parent of root_v). That's correct because depth of i = 0 (i's root is itself). After later attachments, when i is attached to new vertex j, weight[i] will become some w'.\n\nPotential issue: If multiple root_vs are attached to i, we need to set parent of each root_v to i and weight accordingly. This is fine. The root_v's previous parent (itself) changes to i.\n\nPotential issue: After some root_vs are attached, the root of the component (the sink) remains i. But if we later call find(v) on some node v that belongs to this component but whose path passes through root_vs that are now attached to i, find will traverse correctly.\n\nPotential side-case: After we attach root_v to i, we may also need to set parent of i to something else later. This will update weight[i] accordingly.\n\nAll correct.\n\n**Complexities**: O(total edges * \u03b1(n)) time.\n\nNow we need to output total sum modulo MOD.\n\nEdge Cases: maybe there are multiple edges from same root to i? That would cause root_v to be root after path compression? After the first edge, parent[root_v] becomes i, which is not root (since root of root_v's component is i). If there is second edge from same root_v (which is now not a root), then root(v) after first edge would not be root_v (since root(v) is sink; root_v is now internal). So this scenario would require adding edge from non-root to i, violating out-degree \u22641 constraint (since root_v not root). However problem likely forbids this.\n\nNow confirm algorithm on some random test simulation to ensure sum matches explicit simulation (maybe using naive approach for small n). Could also produce random operations and compare DSU sum with naive sum after building adjacency and computing depths for each edge weight using BFS or recursion.\n\nBefore delivering final code, we can thoroughly test with random simulation.\n\n**Testing via mental or small examples**\n\nLet's write a small Python script mental but can simulate manually.\n\nWe'll run small random n up to maybe 10, total edges random, ensure DSU matches naive result.\n\nBut let's do deeper reasoning:\n\nWe need to guarantee that depth(v) + x computed after find(v) is correct in the sense that weight[v] after find includes contributions from all edges added earlier (including edges that attached its previous root(s) to some new nodes). Our DSU automatically accounts for this because of union operations.\n\nHence DSU correct.\n\nPotential pitfalls:\n\n- After find(v) returns root, weight[v] is distance to root. However we must ensure that find(i) for new vertex i returns i and weight[i]=0. We initialize parent[i]=i, weight[i]=0 at start of each operation, but need to ensure that we don't reinitialize for vertices already used later (they already have parent etc). Since we only assign parent[i] and weight[i] for new vertex i before processing edges of that operation. At moment of adding vertex i, it's new, no edges to it previously. So we should set parent[i] = i; weight[i] = 0.\n\nBut if later we add vertex i again? No, vertices are added exactly once. So fine.\n\n**Implementation details: Memory**\n\nParent array: n+1 ints.\n\nWeight array: n+1 ints.\n\nPotential large n: up to maybe 10^6; memory okay (2 arrays of size ~8 bytes each ~8MB each).\n\n**Time Complexity**\n\nProcessing each operation includes O(k) find calls. Each find does path compression. Use recursion may cause recursion depth equal to chain length, which can be up to O(n). Could exceed recursion limit and cause recursion overhead. Better to implement find iteratively.\n\nLet's implement find(x) with while loop and path compression:\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    # Traverse to root, accumulating sum\n    root = x\n    acc = 0\n    # first find root and compute sum from x to root\n    # We'll need to also compress path and update weight for each node.\n    # Approach: use recursion easier.\n    # However recursion depth may be large (e.g., chain of length n=200k, recursion depth might cause recursion limit error, but we can set recursionlimit to maybe 1e6.\n    # Python recursion overhead could be okay but might be slower.\n    # We'll implement recursion but set recursionlimit.\n\nI think recursion is simpler, we can maybe use recursion.\n\nBut we also need to import sys and set recursionlimit: sys.setrecursionlimit(1000000*2 maybe).\n\nOk.\n\nLet's design code accordingly.\n\nNow parse input: Since input size may be big, use sys.stdin.buffer.read().\n\nImplementation steps:\n\nimport sys\n\ndef solve():\n    import sys\n    MOD = 1000000007\n    data = list(map(int, sys.stdin.buffer.read().split()))\n    it = iter(data) (or index pointer).\n    n = data[0]; idx = 1\n    parent = [i for i in range(n+1)]\n    weight = [0]*(n+1)\n    total = 0\n\n    # function definitions inside solve for local access to MOD and arrays\n    sys.setrecursionlimit(1_000_000)\n\n    def find(x):\n        if parent[x] != x:\n            p = parent[x]\n            root = find(p)\n            weight[x] = (weight[x] + weight[p]) % MOD\n            parent[x] = root\n        return parent[x]\n\n    # Process operations\n    for i in range(1, n+1):\n        # Ensure parent[i] and weight[i] initialized; they currently have default values from initialization.\n        # If they have been altered earlier (should not be) but just in case, we could set:\n        # parent[i] = i\n        # weight[i] = 0\n        # But we already set them to these values initially. However after previous attachments, we may have changed parent[i] to new vertex. That would happen only after i is added and later becomes a child of later vertex. That will happen later. So at the moment of addition, we need i to have parent[i]=i. However parent[i] may have been previously set to something else due to earlier operations? No, because i hasn't existed before; it's a new vertex number, we have not assigned any parent. So we must set parent[i] = i initially. So we should do that inside the loop:\n        parent[i] = i\n        weight[i] = 0\n        k = data[idx]; idx += 1\n        for _ in range(k):\n            v = data[idx]; x = data[idx+1]; idx += 2\n            # compute depth(v) and root(v)\n            root_v = find(v)          # This also compresses v's path and updates weight[v]\n            depth_v = weight[v]       # now weight[v] = distance to root_v\n            w = (depth_v + x) % MOD\n            total = (total + w) % MOD\n            # union: attach root_v to i\n            parent[root_v] = i\n            weight[root_v] = w\n    # After all operations, total sum is computed.\n   "}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "", "thinking": "The user wants a single tool call with the solution code. I need to output the solution using the `submit_solution` tool.\n\nThus I need to produce the final solution code (complete Python script) that reads input from stdin, processes as described, prints the sum of edge weights modulo 1e9+7.\n\nBe careful about formatting: The prior attempt gave a partial solution in the explanation but not the final answer as a tool call.\n\nThus we need to output a single tool call: `submit_solution` with the code string.\n\nThe code should be inside the Python script: define a `solve()` function, or just code at top-level.\n\nWe need to make sure to handle reading input, processing as per algorithm, and printing answer.\n\nPotential complexities: ensure we set recursion limit high enough, but we can also implement find iteratively to avoid recursion.\n\nLet's create robust final solution.\n\n**Potential pitfalls**:\n\n- Input may contain lines with many numbers; using data = sys.stdin.buffer.read().split() and mapping to int is fine.\n\n- Have to ensure handler for large recursion: we can either implement iterative find or set recursionlimit high.\n\n- Provide careful about resetting parent[i] and weight[i] each iteration for new vertex i (ensuring it's a root). Since we initially allocated arrays and set parent[i]=i, weight[i]=0 before loop. However we need to do it each iteration because for i after being used as sink in previous iteration we will later attach it to later vertex, which changes its parent. In the iteration where i is added, parent[i] should be i. Doing parent[i] = i inside loop ensures this (overwrites previous parent if any). In addition, we also need to set weight[i] = 0.\n\nPotential concurrency: For i that has been previously attached (i.e., i appears as v in later edges), we will still have its parent pointing to some later vertex. It may have been compressed. That's fine.\n\nNow implement find function using iteration to avoid recursion overhead.\n\n**Iterative find with path compression**:\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    # else need to find root and compress.\n    # accumulate total weight from x to root.\n    # We'll need to update weight[x] to total weight, and parent[x] to root.\n    # Approach: traverse up and store nodes along path.\n    nodes = []\n    w_sum = 0\n    while parent[x] != x:\n        nodes.append(x)\n        w_sum = (w_sum + weight[x]) % MOD\n        x = parent[x]\n    root = x\n    # Now nodes contains the nodes from original node down to just before root.\n    # Actually we need to compress path: for each node in nodes, set parent[node] = root and weight[node] = appropriate.\n    # However w_sum currently is sum of full chain from original node to root; but we need to set weight for each node individually.\n    # We can recompute by walking again, but simpler to use recursion; we'll use recursion.\nGiven constraints, recursion is simpler.\n\nWe can use recursion and set recursionlimit to e.g., 1_000_000.\n\nProbably safe.\n\nNow we need to handle depth(v) after find(v). As per earlier, weight array stores difference to parent. After find(v) call, weight[v] will be distance to root.\n\nThus we compute root_v = find(v) and depth_v = weight[v].\n\nPotential issue: find(v) path compresses and may set parent[v] = root_v and weight[v] = depth_v. That's good.\n\nNow w = (depth_v + x) % MOD.\n\nNow union: parent[root_v] = i; weight[root_v] = w.\n\nPotential edge-case: If root_v == i (i.e., we are attaching i to itself), which would happen if they pass v such that root(v) = i (v in same component as i, maybe i is root). But i is newly added vertex with no outgoing edges, so it is its own root. However if v is also i? Could be possible: they could reference v = i (the vertex being added). In that case root(v)=i, depth(v)=0 (since no outgoing edge). Edge from i to i with weight x? That would be self-loop and out-degree from i becomes 1, still okay maybe? But operation says edges go from root(v_j) to vertex i. If v_j = i, root(i) = i (since new vertex added), depth(i) = 0, weight = 0 + x, so edge from i to i weight x - self-loop. Does this violate forest property? It would create a cycle of length 1, violating acyclic property. So likely v_j will be less than i (since vertices are added sequentially and maybe only refer to previously existing vertices). So we can assume v_j < i.\n\nThus we won't have root_v == i.\n\nNow final sum total printed as integer.\n\nNow consider overflow: total may be Python int; we keep modulo each addition.\n\nNow we need to handle negative x. Use w = (depth_v + x) % MOD: In Python, (a + b) % MOD yields non-negative even if b negative.\n\nNow finalize.\n\n**Potential issues: The DSU weight in union step is w (mod MOD). When later depth calculations use weight values, they should also be modded. This ensures sum modular.\n\nTest with some random small input, compare to naive compute.\n\nWe'll write quick simulation for random n up to maybe 100, total edges random.\n\nWill run on local mental.\n\nBut to be safe, we will also write a test harness within the solution? Not needed.\n\nNow about reading: The first integer is n, then for each i we read k and then k pairs. Some problems might have multiple lines per operation, but our token reading handles it.\n\nPotential situation: There may be extra whitespace after last integer: fine.\n\nNow possible memory: We'll hold parent and weight arrays sized n+1. n may be up to 10^6, fine.\n\nOk.\n\nNow produce final code.\n\nWe need to wrap code into a function solve() and call at the end.\n\nExample:\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1_000_000)\n    MOD = 1000000007\n    data = list(map(int, sys.stdin.buffer.read().split()))\n    if not data:\n        return\n    idx = 0\n    n = data[idx]; idx+=1\n    parent = [i for i in range(n+1)]\n    weight = [0]*(n+1)\n    total = 0\n    def find(x):\n        if parent[x] != x:\n            p = parent[x]\n            root = find(p)\n            weight[x] = (weight[x] + weight[p]) % MOD\n            parent[x] = root\n        return parent[x]\n    for i in range(1, n+1):\n        parent[i] = i\n        weight[i] = 0\n        k = data[idx]; idx += 1\n        for _ in range(k):\n            v = data[idx]; x = data[idx+1]; idx += 2\n            root_v = find(v)\n            depth_v = weight[v]  # after find, weight[v] is distance to root\n            w = (depth_v + x) % MOD\n            total = (total + w) % MOD\n            parent[root_v] = i\n            weight[root_v] = w\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()\n\nWe need to ensure that weight[v] after find(v) is indeed depth modulo MOD. However note that after find(v) path compression, weight[v] = sum of weight along path to root modulo MOD (since we do mod each addition). That's fine.\n\nPotential issue: When we compute depth_v = weight[v], there is a subtle nuance: After find(v), parent[v] might be root, but weight[v] is the distance to root; but we need depth(v) to root (sum of edge weights from v to root). That's correct.\n\nNow we need to ensure that for each pair we recompute find(v), not using stale root after previous unions have changed its component. That's fine.\n\nNow final answer is total % MOD printed.\n\nEdge Cases:\n\n- n=0? The problem says n operations but maybe n>0. If n=0, we skip loop and output 0.\n\n- k maybe zero: then no pairs loop; we just set parent[i] and weight[i]; no changes to total.\n\nCheck for sample? No sample provided.\n\nConsider a bigger test:\n\nCase: n=4\nOps:\n1: k=0\n2: k=0\n3: k=2: v1=1 x1=5; v2=2 x2=7\n4: k=1: v1=3 x1=2\n\nNow compute manually:\n\nAfter op1: node1 sink.\nAfter op2: node2 sink.\nOp3: add node3, edges from root(1) -> 3 weight 0+5=5; from root(2)->3 weight 0+7=7. Sum=12. After op3, node1->3 weight5, node2->3 weight7; node3 sink.\n\nOp4: add node4, edge from root(3) ->4: root(3)=3 (since node3 sink). depth(3) = 0 (no outgoing). weight = 0 +2=2. Sum total = 12+2=14.\n\nThus expected 14.\n\nNow run our algorithm:\n\nInitialize parent[1]=1 weight[1]=0; parent[2]=2; ... etc.\n\ni=1: parent[1]=1, weight[1]=0; k=0.\n\ni=2: parent[2]=2 (re-init) weight[2]=0; k=0.\n\ni=3: parent[3]=3, weight[3]=0; k=2.\n\nFirst pair v=1,x=5:\n\nfind(1): parent[1]=1, root=1, weight[1]=0. depth=0; w=5; total=5; parent[1]=3 weight[1]=5.\n\nSecond pair v=2,x=7:\n\nfind(2): parent[2]=2; depth=0; w=7 total=12; parent[2]=3 weight[2]=7.\n\ni=4: parent[4]=4 weight[4]=0; k=1.\n\nPair v=3,x=2:\n\nfind(3): parent[3]=3 (since no outgoing). w=2? depth(3)=0. w=2. total=14. parent[3]=4 weight[3]=2.\n\nOk.\n\nNow compute depths manually later: depth(1) = 5 + 2? Actually after edge 3->4 weight2 added, depth(1) should be 5+2=7; depth(2) = 7+2=9; depth(3) = 2. Let's test DSU after all operations:\n\nAfter all, parent[1]=3, weight[1]=5; parent[2]=3 weight[2]=7; parent[3]=4 weight[3]=2; parent[4]=4 weight[4]=0.\n\nNow find(1): parent[1]=3 weight[1]=5; find(3): parent[3]=4 weight[3]=2; parent[4]=4; weight[3] stays 2; parent[3]=4; weight[1] = weight[1] + weight[3] = 5+2=7; parent[1]=4. So depth(1)=7. Good.\n\nThus DSU works.\n\nNow maybe there are more complex scenarios where root(v) has depth > 0 (i.e., v is not a root). Already covered.\n\nNow consider scenario where after many operations, many nodes point to same child (e.g., multiple roots attached to one vertex i). All good.\n\nNow bigger scenario: Suppose after constructing forest, need sum of weights of all edges. The DSU algorithm calculates w for each edge and adds to total. This sum matches construction edges. Since each edge is added exactly once, sum computed correct.\n\nThus algorithm is correct.\n\nNow final code: We'll implement solve() as defined.\n\nPotential memory reduction: Use lists of int; okay.\n\nEdge Cases:\n\n- The number of edges may be large; we may need to set recursionlimit.\n\nLet's also consider possibility that depth_v + x may overflow Python int if we use normal ints; but Python int arbitrary, but we modulo each step. We'll do w = (depth_v + x) % MOD.\n\nObservation: x can be negative; Python's % returns non-negative remainder.\n\nPotential tricky: Python's modulo of negative numbers returns positive remainder: e.g., -3 % 7 = 4. That's fine.\n\nNow what about weight (sum) using modulo: weight values may become negative? Because we do modulo at each addition ensures they stay in [0, MOD-1]. Union step weight[root_v] = w; w is modulo MOD, non-negative.\n\nThus all good.\n\nNow think about scenario where x may be huge ( > MOD), w = (depth_v + x) % MOD. This eliminates contributions above MOD. However our final answer is required modulo MOD. That's ok.\n\nBut does depth computed later using weight values (which are modulo) produce depth modulo MOD, which may not reflect true depth for the purpose of future w computations modulo MOD? However as we argued, addition modulo is linear: (True_depth + x) % MOD = ((depth_mod) + x) % MOD only if depth_mod = True_depth % MOD, which we maintain. Since each weight is stored modulo MOD, each sum depth modulo is correct. So fine.\n\nNow consider if we need to compute sum of all edge weights modulo M. Skew is fine.\n\nNow code's readability: we can comment.\n\nNow we also need to include at the end:\n\nif __name__ == \"__main__\":\n    solve()\n\nNow produce final tool call.\n\nBefore final, let's consider potential edge-case: Input may have operations where some vertex is root of many others but still has no outgoing edges until it's attached to new vertex i; but later attachments may cause multiple outgoing edges? Wait a vertex can have at most one outgoing edge (by definition). This is enforced by operations: we only attach a root to new vertex i, thus each root can be attached at most once (since after attached, it's no longer root, it's out-degree 1). However a vertex could be root multiple times if after it becomes internal node, later operation may refer to some v such that root(v) = that vertex again? Could that happen? Let's consider:\n\n- Node a is a root initially, then attached to b (i.e., edge a->b). Now a has outgoing edge to b, indegree maybe some. However root(v) for some vertex v that is in a's component (including a itself) after this operation might be b (the sink). So later operations might have v such that root(v) is b, not a. So a will never be root again.\n\nBut is it possible for a vertex to be root and later after being attached, later become root again? For it to become root again, its outgoing edge would need to be removed or reversed, which does not happen. So each vertex can be attached at most once (as a root). So DSU union operations attach root only once. However a vertex may be a root of its component originally when added (sink). Later it can be attached as root to a later vertex; after that it will never be root again. So our union operation attaches root_v (which must be a root currently). According to DSU, parent[root_v] was root_v itself before union. We set it to i. That's fine.\n\nNow what about a vertex being attached as root to i, but also had previously been attached and thus parent changed? That cannot happen because root_v is root before union, so it hasn't been attached before. How can root_v exist as root? It might have previously been root of its component (always). The first time it's attached is when we set parent[root_v] = i, after that parent[root_v] != root_v. So cannot be root again.\n\nThus union attaches each root at most once.\n\nThis ensures DSU tree is a forest of directed edges from original root to new sink.\n\nNow we need to trust that input respects this; if not, our algorithm may attach a vertex that already has outgoing edge, causing out-degree >1, violating assumptions and messing up DSU because parent[root] might not be root. The problem probably guarantees this.\n\nThus algorithm is fine.\n\nNow let's produce final solution code.\n\n**Testing with random naive simulation**:\n\nWe'll also prepare a test harness for small n.\n\nWe'll create naive representation: For each node, store child (outgoing) and weight to child. For each operation, compute root of v by traversing child pointers until node with child -1 (sink). Compute depth by summing weights. Then add edge: set child[root]=i, weight[root]=w. After all ops, compute sum of all edge weights - but we also compute sum as we go.\n\nCompare sum computed by algorithm (the DSU method) with naive's sum.\n\nSince we can't run code here but we can mentally test some scenarios. Let's do a more complex random example mentally: n=5, operations:\n1: k=0 -> node1\n2: k=1: v=1 x=2 -> edge 1->2 w=2\n3: k=1: v=2 x=3 -> root(2)=2? After op2, 2 is sink. So op3 adds edge 2->3 w = depth(2)+3. depth(2) = 0 (since no outgoing). w=3. Sum now 2+3=5.\n4: k=2: v=1 x=4, v=3 x=5 -> Let's compute: (i=4)\n   - v=1: root(1) = 3? Actually after earlier ops, root(1) is the sink of component containing 1. After op3, we have edges: 1->2 weight2, 2->3 weight3. The sink is node3 (since node3 has no outgoing edges). So root(1) = 3. depth(1) = weight from 1 to root: 2+3=5. w1 = depth(1) + 4 = 9.\n   - v=3: root(3)=3 (it is sink, depth(3)=0). w2 = depth(3) + 5 = 5.\n   Add edges: 3->4 weight 9; and another edge 3->4 weight 5? Actually both edges originate from root(1) (which is 3) and root(3) (which is 3 again). This would be two edges from same source 3 to 4 with weights 9 and 5 respectively. That violates out-degree \u2264 1 for vertex 3. So such input should not occur. Indeed operations are probably designed to avoid this.\n\nThus test should maintain distinct root vertices. Let's try other scenario: In op4, choose v's from distinct components. For example v1 = 2 (component of {1,2,3}) maybe root is 3 again, same root. So not distinct; need distinct. Maybe choose v1=1 (root 3) and v2=some vertex from separate component (like vertex from other tree). But currently we only have one component. So we need to add more components earlier.\n\nLet's design a new scenario: n=6.\nOp1: k=0 -> node1\nOp2: k=0 -> node2\nOp3: k=1 v=1 x=5 -> edge 1->3 weight5\nOp4: k=1 v=2 x=7 -> edge 2->4 weight7\nNow we have two components: component A: 1->3 sink=3; component B: 2->4 sink=4.\nOp5: k=2 v=3 x=2 v=4 x=3 -> i=5, edges: root(3)=3, depth(3)=0 => w1=2 (3->5 weight2)\nroot(4)=4 depth(4)=0 => w2=3 (4->5 weight3). Sum total = 5+7+2+3 = 17.\n\nNow root(3) and root(4) are distinct; after adding edges, both become internal nodes, both point to 5. Vertex5 is sink. OK. Out-degree of 3 and 4 each 1.\n\nOp6: maybe have v=1 (path to root is 3->5) root(1) is current root of component containing 1; after op5, root of component A is node5 (sink). So root(1) = 5, depth(1) = 5 (1->3 weight5 + (none from 3->5 weight2) maybe? Actually weight from 3->5 is 2; So depth(1) = weight(1->3) + weight(3->5) = 5 + 2 =7.\n\nNow add vertex6 with say v=1 x=10 etc.\n\nLet's test algorithm for op6.\n\nProcess step-by-step:\n\nData structures:\n\nInitialize parent[1]=1 weight[1]=0; parent[2]=2; parent[3]=3; parent[4]=4; parent[5]=5; parent[6]=6.\n\nAfter op3 (edge 1->3 weight5): we do find(1) root=1 depth=0; w=5; total+=5; parent[1]=3 weight[1]=5.\n\nAfter op4 (edge 2->4 weight7): find(2) root=2 depth=0; w=7; total+=7 (total 12); parent[2]=4 weight[2]=7.\n\nNow after op5 (edges 3->5 weight2 and 4->5 weight3):\n- For v=3 x=2: find(3): parent[3]=3 root=3, depth=0. w=2; total+=2 =>14.\n   union: parent[3]=5 weight[3]=2.\n- For v=4 x=3: find(4): parent[4]=4 root=4, depth=0. w=3; total+=3 =>17.\n   union: parent[4]=5 weight[4]=3.\n\nNow after op5, we have parent[1]=3 weight[1]=5; parent[3]=5 weight[3]=2; parent[5]=5 weight[5]=0.\n\nAlso parent[2]=4 weight[2]=7; parent[4]=5 weight[4]=3.\n\nNow root of component containing 1 is 5. depth(1) = weight[1] + weight[3] = 5+2=7.\n\nNow op6: i=6, suppose k=1 v=1 x=10.\n\n- find(1). Path: parent[1]=3, parent[3]=5. Let's simulate recursion: find(1):\n   parent[1]!=1 => p=3; find(3):\n       parent[3]!=3 => p=5; find(5) returns 5 (as parent[5]==5) => root=5.\n   weight[3] = (weight[3] + weight[5]) = 2+0 =2; parent[3]=5.\n   weight[1] = (weight[1] + weight[3]) = 5 + 2 =7; parent[1]=5.\n   returning root=5.\n\nNow weight[1]=7, depth(1)=7. root_v = 5 (parent[1]=5). So root(v) = 5.\n\nw = depth_v + x = 7 + 10 = 17 (mod M). total = previous total (17) + 17 = 34.\n\nNow union: parent[5] = 6, weight[5] = w = 17.\n\nNow after union, root for all nodes should be 6. Depth calculations should hold.\n\nNow total sum of edge weights: edges and weights: 5,7,2,3,17 = 34. So matches. Good.\n\nThus algorithm correct.\n\nNow consider scenario where k>1 and roots are distinct. Works.\n\nNow let's test scenario where depth values large and many nodes.\n\nPerformance: O(total edges * \u03b1(n)). Weighted union find with recursion may cause deep recursion for long chains. Each find may traverse chain length up to O(depth). With path compression, each find reduces path length drastically, so recursion depth rarely high. But worst-case before much compression, chain length may be up to n e.g., 200k. At most recursion depth 200k, which may exceed default recursion limit 1000, causing RecursionError. However we will set recursionlimit to maybe 1_000_000 to handle large. Python recursion may still have overhead but okay.\n\nAlternatively we could implement find iterative. Let's evaluate:\n\nWe could implement find using while loop without recursion like:\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    # accumulate weight\n    # Need both root and sum weight from x to root.\n    # Approach: traverse up, saving nodes along path.\n    nodes = []\n    cur = x\n    while parent[cur] != cur:\n        nodes.append(cur)\n        cur = parent[cur]\n    root = cur\n    # Now propagate back: set weight for each node.\n    # Actually we need to compute prefix sums from each node to root.\n    # Here is method: iterate nodes in reverse order (from top-most to x) to adjust weight.\n    # Let cumulative weight from node to root.\n    # Example: nodes list = [x, p1, p2, ..., pk] where parent[pk] = root (parent[root]==root).\n    # Not exactly: The while loop stops at root where parent[root]==root. So nodes list includes x, parent[x], parent[parent[x]], etc., but not root.\n    # Actually root not in nodes list (since parent[root]==root). Let's include root as the last node if we want? Not necessary.\n    # Let's look at typical algorithm: we compress path by setting parent of each node directly to root and updating weight to sum of weights along path.\n    # So we need to compute for each node the sum of weight from node to root.\n    # we can precompute prefix sums from node to root: can compute total sum from node to root by summing weight[node] for each node while traversing then assign.\n    # But we can also use recursion easier.\n    # So we might stick with recursion.\n\nOk.\n\nNow about memory: parent and weight arrays each size n+1 as Python lists. This is fine.\n\nNow let's consider potential optimisation: use list comprehension to initialize parent: parent = [i for i in range(n+1)]. Works.\n\nNow about reading: Using data = sys.stdin.buffer.read().split() may produce bytes; need to convert to int. We'll do map(int, ...) which is fine.\n\nNow some testcases:\n\nCase: n=1, operation 1: k=0 => no edges. Sum=0. Code should output 0.\n\nCase: n=2; op1 k=0; op2 k=1 v=1 x=0 => weight = depth(1)+0 = 0 => total 0 sum? Edge weight zero; sum=0.\n\nCase: large n with many zeros.\n\nAlright.\n\nNow produce final answer.\n\nNow write final code as a string for tool call.\n\nMake sure code runs without errors.\n\nPotential catch: For each i we are resetting parent[i] and weight[i] (overwriting any previous values). However after i has been used as a sink (its parent set to i), later when i becomes root for some other node (i.e., edge from i to later node j), we will attach i (as root) to j. In that later operation, we will call find(v) on some vertex belonging to component whose sink currently is i. That will return root i (since parent[i] may have been changed already). However during that later operation, we must not reinitialize parent[i] again (reset to i). Since that later operation is for vertex j > i, the loop will be for j, not for i. So we won't reinitialize parent[i] again. Our loop only initializes parent[i] for the current vertex i at the time of its creation. Later when i becomes root of some component, we may still have parent[i] not equal i (it may be something else). That's fine.\n\nThus we must only set parent[i]=i and weight[i]=0 when vertex i is first added. Since we allocate arrays at start and fill them, we should set them again in loop for safety anyway because they may have been previously set to i? Actually they are never set before; we defined arrays with default parent[i] = i, weight[i]=0. So we could skip the initialization inside loop. However as we said we need to ensure that at time of creation, parent[i]=i and weight[i]=0, regardless of what was there before (maybe leftover from previous loops if we are reusing arrays?). Not needed for first time; but for clarity we can set them.\n\nNow concerning memory: We may allocate parent and weight arrays sized n+1 and fill with initial values (list comprehension). We need to maybe fill 'parent' with i, but parent[i] can later be changed. That's fine.\n\nNow we should consider that we need to read the entire input. Are there blank lines? Not a problem.\n\nPotential obstacle: The problem may have multiple test cases? Not specified; assume single test.\n\nNow produce final answer.\n\nNow produce final tool call with the code.\n\nProceed to final.", "tool_calls": [{"type": "function", "id": "functions.submit_solution:0", "function": {"name": "", "arguments": "{\"python_code\": \"import sys\\n\\nMOD = 1000000007\\n\\ndef solve() -> None:\\n    data = list(map(int, sys.stdin.buffer.read().split()))\\n    if not data:\\n        return\\n    idx = 0\\n    n = data[idx]\\n    idx += 1\\n\\n    # DSU structures: parent[x] is the next node towards the sink (the representative)\\n    # weight[x] stores (depth[x] - depth[parent[x]]) modulo MOD.\\n    parent = [i for i in range(n + 1)]\\n    weight = [0] * (n + 1)\\n\\n    sys.setrecursionlimit(2 * 10 ** 6)\\n\\n    def find(x: int) -> int:\\n        \\\"\\\"\\\"Returns the current sink (representative) of the component containing x.\\n           Also performs path compression and updates weight[x] to be the distance from x to the sink.\\\"\\\"\\\"\\n        if parent[x] != x:\\n            p = parent[x]\\n            root = find(p)\\n            weight[x] = (weight[x] + weight[p]) % MOD\\n            parent[x] = root\\n        return parent[x]\\n\\n    total = 0\\n    for i in range(1, n + 1):\\n        # Vertex i is a new sink initially.\\n        parent[i] = i\\n        weight[i] = 0\\n\\n        k = data[idx]\\n        idx += 1\\n        for _ in range(k):\\n            v = data[idx]\\n            x = data[idx + 1]\\n            idx += 2\\n\\n            # find the current sink and depth of v\\n            root_v = find(v)\\n            depth_v = weight[v]  # after find, weight[v] == distance from v to its sink\\n\\n            w = (depth_v + x) % MOD\\n            total = (total + w) % MOD\\n\\n            # attach the sink (root_v) to the new vertex i with edge weight w\\n            parent[root_v] = i\\n            weight[root_v] = w\\n\\n    print(total)\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"}"}}]}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "{\"python_code\": \"import sys\\nMOD = 1000000007\\ndef solve():\\n    data = list(map(int, sys.stdin.buffer.read().split()))\\n    if not data:\\n        return\\n    idx = 0\\n    n = data[idx]\\n    idx += 1\\n    parent = [i for i in range(n + 1)]\\n    weight = [0] * (n + 1)\\n    sys.setrecursionlimit(2 * 10**6)\\n    def find(x):\\n        if parent[x] != x:\\n            p = parent[x]\\n            root = find(p)\\n            weight[x] = (weight[x] + weight[p]) % MOD\\n            parent[x] = root\\n        return parent[x]\\n    total = 0\\n    for i in range(1, n + 1):\\n        parent[i] = i\\n        weight[i] = 0\\n        k = data[idx]\\n        idx += 1\\n        for _ in range(k):\\n            v = data[idx]\\n            x = data[idx + 1]\\n            idx += 2\\n            root_v = find(v)\\n            depth_v = weight[v]\\n            w = (depth_v + x) % MOD\\n            total = (total + w) % MOD\\n            parent[root_v] = i\\n            weight[root_v] = w\\n    print(total)\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"}", "thinking": "The user is complaining that the response is not correctly formatted. It expects a single tool call to submit_solution, with the code as argument. I previously attempted to call submit_solution with a Python string, but maybe the format is wrong: The string should contain the code only, not include the surrounding quotes? Actually it's a JSON object with key \"python_code\". The value is a string containing the code. In my last attempt, I passed a JSON with proper quoting, but the system says it's still wrong. Let's try again.\n\nWe need to ensure:\n\n- Use a single tool call: exactly one call to submit_solution.\n- The python_code field must be a string containing the entire solution script.\n- Must read from stdin, print output.\n\nI think my previous attempt used triple quotes inside JSON string, but that's fine, JSON strings can have newline characters escaped? Actually I typed a JSON object directly in the chat, not as raw JSON but using python-like representation; the tool interface expects a JSON object. The previous call seems correct: I passed {\"python_code\": \"import sys\\n\\n...\"}.\n\nPotentially the issue is there are multiple lines of code inside the string, which is okay because the JSON can have multi-line string? In the chat representation, they treat it as a code block. The system might need the string to be raw without extra quoting. However historically earlier tasks had similar usage. Let\u2019s search memory.\n\nWe have to produce: \n\n{\n  \"python_code\": \"import sys\\n\\nMOD = 1000000007\\n\\ndef solve() -> None:\\n    data = ... etc\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"\n}\n\nThis should be accepted.\n\nBut maybe the system expects escape sequences for newlines? Possibly they want actual line breaks within the JSON string; they usually accept multi-line string in the chat as they treat it as raw text. In earlier tasks, I've used the same format and it works.\n\nMaybe the error arises because my code includes extraneous print statements outside solve? Actually I only have print(total) inside solve. That's okay.\n\nBut maybe the user expects the solution to be a simple script without function definition? But earlier tasks accepted function definitions.\n\nAnother possibility: The solution may require using Python's big integers and not mod for internal depth values because subsequent depth values may rely on actual weights for later w calculation (mod may break correctness if x not modulo?). But they only ask for sum modulo mod at the end, internal mod should be ok as argued. But maybe they want to compute full weight values (which may become huge) and only take mod at the end; but Python can handle big ints, but could be extremely huge (size O(n) product of weights)? Edge weight can be up to maybe 10^9 + depth which can be sum of many edges, maybe up to n*10^9 ~ 10^14, okay but not insane. Could be bigger if x is bigger. But Python can handle arbitrarily large ints albeit slower. But they might want mod each step for efficiency.\n\nNevertheless, the algorithm should compute correct sum.\n\nBut need to double-check algorithm for negative x: w = (depth_v + x) % MOD yields positive modulo.\n\nNow, what about root(v) and depth(v) queries for nodes where path lengths may be huge; weight values stored modulo MOD can cause depth modulo MOD only; but later we calculate w = depth(v) + x modulo MOD, which is fine.\n\nPotential issue: if both depth and x are negative (or x negative depth maybe negative?), we need modulo to preserve sum mod M. Since they ask sum of weights modulo M, we only need each w modulo M. However if depth is used later as part of weight for later edges, we need correct modulo of depth too, as we are adding to w again. Since total sum is linear and each w is (depth + x) mod M, and depth itself is sum of earlier w's, then using modulo at each step still yields correct final sum modulo M.\n\nThus algorithm correct.\n\nNow final solution: I need to output only a single tool call with code as a string.\n\nBefore I repost, let's examine my code for any possible bug.\n\nRead of input:\n\ndata = list(map(int, sys.stdin.buffer.read().split()))\n...\nn = data[0]; idx=1\n\nBut need to handle case where n=0? But n>0 as per problem. However we can put check.\n\nLoop for i in range(1, n+1):\n   parent[i] = i\n   weight[i] = 0\n\n   k = data[idx]; idx+=1\n\n   for _ in range(k):\n        v = data[idx]; x = data[idx+1]; idx+=2\n\nBut careful: If k may be 0, there might be no pairs. That's fine.\n\nBut need to ensure data length matches; should.\n\nNow compute depth_v = weight[v] after find(v). However after find(v), weight[v] may be changed (if path compression). That's okay.\n\nPotential bug: When we call find(v) for the same node multiple times in same operation (if same v appears multiple times in list). After first call, weight[v] will equal distance to its sink (which after union may be changed?). But before union we call find(v) to compute depth and root; after union of root to i, v remains part of the component but sink changes; weight[v] previously was distance to old sink; after parent[root] changed to i, weight[v] still reflects distance to old sink; but that's fine because we only need depth(v) at this moment (before adding edges). Since we call find(v) before union, we get correct depth(v). However after we union, we may also call find(v) again if v appears again later in same operation (like v appears twice). In that scenario, we would compute root(v) again after the root changed (it may now be i). But they said we should compute root(v) before processing edges; thus v duplicates might not be allowed. If duplicates allowed, they should probably be considered based on initial state. However our algorithm would treat second occurrence as after first union, which might be inconsistent. However likely duplicates are not allowed. We can ignore.\n\nPotential bug: The weight[v] after find(v) may be large and used as depth_v for w. That is correct.\n\nAfter union, we set parent[root_v] = i; weight[root_v] = w. However root_v variable holds root of component containing v at start. If there are multiple v's that share same root_v, we would attempt to set parent[root_v] twice (once per each pair). Since root_v becomes child after first union, second time root_v is no longer a root; parent[root_v] is no longer root_v but now i; we would be resetting its parent and weight, which would break the structure. Therefore duplicates cannot happen. Should be fine.\n\nAlso need to keep in mind that after union we didn't update weight[i] (should be 0). That's fine.\n\nNow final sum printed: print(total). That's all.\n\nNow need to test with random small n naive.\n\nLet's simulate manually with simple naive algorithm in separate mental process:\n\nDefine adjacency as dict: for each node, store outgoing edge (child, weight) if any. Depth and root can be computed by traversing forward following child pointers (sink). Compute root by while child exists: node = child. Accumulate depth sum.\n\nDuring each operation i:\n\n- add node i with no outgoing edge.\n- for each pair (v, x):\n    - compute root = root(v) (by following child pointers until None).\n    - compute depth = depth(v) by summing weights along that path.\n    - w = depth + x\n    - sum += w\n    - add outgoing edge from root to i with weight w: set child[root] = i; weight[root] = w\n\nAfter processing all edges for i, node i remains with no outgoing edges.\n\nThus for small n we can simulate.\n\nNow test with some random sequence to verify DSU algorithm matches naive.\n\nLet's code a test offline.\n\nConsider n=5 arbitrary pairs.\n\nBut we cannot run code here. Let's emulate execution manually for a more complex scenario.\n\nLet's attempt a random configuration:\n\nExample:\n\nn=5\n\nOperations:\n\n1: k=0 (add vertex 1)\n\n2: k=1: v=1, x=3 (add edge root(1) -> 2 weight 0+3=3)\n\n3: k=1: v=2, x=5 (add edge root(2) -> 3 weight ??? depth(2) after previous step)\n\nCompute manually:\n\nAfter op2, we have 1->2 weight 3. Depth(1)=3, root(1)=2, depth(2)=0.\n\nNow op3: v=2. Need root(2) = 2? Actually root(2) is vertex 2 (since out-degree 0). depth(2) = 0. So edge root(2) -> 3 weight 0+5=5. After op3: edges: 1->2 w=3, 2->3 w=5. Depth(1)=3+5=8, depth(2)=5.\n\nNow suppose op4: k=2; edges: (v=1, x=10), (v=2, x=20).\n\nCompute before op4:\n\n- root(1) = 3? Let's compute: Starting from 1, go child to 2, then child to 3, then 3 has no child => root(1)=3. depth(1)=3+5=8.\n\n- root(2) = 3. depth(2)=5.\n\nNow add vertex 4, edges:\n\n- edge from root(1)=3 to 4 with weight depth(1)+10 = 8+10=18\n\n- edge from root(2)=3 to 4 with weight depth(2)+20 =5+20=25\n\nBut notice both edges originate from same root 3 -> 4; that would cause out-degree of 3 being >1. That's not allowed. So such operation cannot appear in valid input. So we deduce they guarantee edges to have distinct roots. Good.\n\nAlternative operation: maybe op4 with v=1 only. Then weight is 8+10=18, edge 3->4 weight 18.\n\nNow depth values after op4 become depth(3)=18, depth(2)=5+18=23, depth(1)=8+18=26 etc.\n\nNow DSU algorithm should handle.\n\nLet's test DSU manually:\n\nInitialize parent[1]=1 w[1]=0.\n\ni=1: k=0.\n\ni=2: k=1 v=1 x=3.\n\n- find(1) root=1 depth=0. w=3. total=3.\n- union: parent[1]=2 weight[1]=3.\n\ni=3: k=1 v=2 x=5.\n\nWe need to compute depth(v) where v=2. Vertex 2 hasn't been used as child yet, so parent[2]=2 weight[2]=0 (since we set at start of loop). find(2) returns root=2, depth=0. w = 0+5=5. total=8. union: parent[2] = 3 weight[2]=5.\n\nNow tree: 1->2 (weight 3), 2->3 (weight5). DSU: parent[1]=2 weight[1]=3; parent[2]=3 weight[2]=5; parent[3]=3 weight[3]=0.\n\nNow i=4: k=1 v=1 x=10.\n\nCompute find(1):\n\nparent[1]=2, call find(2). parent[2]=3, call find(3) => root=3. weight[2] = (5 + weight[3]) =5; parent[2]=3. weight[1] = (3 + weight[2]) =8; parent[1]=3. So find(1) returns root 3, weight[1]=8 (depth). Good.\n\nThus depth(v) = 8.\n\nw = 8+10 = 18; total=26.\n\nroot_v = find(v) = find(1) which returned 3. So parent[3]=4, weight[3]=w=18.\n\nNow DSU after: parent[3]=4 weight[3]=18; parent[4]=4 weight[4]=0.\n\nNow depth for any node can be computed correctly.\n\nCheck depth(2): find(2) will compress: parent[2]=3, but parent[3]=4 now; weight[2]=5; find(3) => root=4, weight[3]=18. So weight[2] after path compression: weight[2] = weight[2] + weight[3] = 5 + 18 = 23; parent[2]=4. depth(2)=23, which matches 5+18=23. Good.\n\nThus DSU works.\n\nNow more complex scenario: multiple roots in same operation: need distinct roots. DSU will attach each root to i. After first union, i becomes sink. After second union, root2 is attached to same i. That's fine.\n\nNow scenario: maybe k may be zero for many vertices, then later some root will attach to later vertex. DSU works.\n\nThus algorithm correct.\n\nPotential memory/permutation concerns: Some vertices may never be used as v (source) but that is fine.\n\nNow need to code final solution with necessary imports.\n\n**Testing more random simulation**\n\nLet's write some Python code to test DSU vs naive for random small n.\n\nWe'll create a script; but here I can reason.\n\nBut will replicate typical random scenario.\n\nPotential pitfalls: need to be careful about Python recursion depth; set recursionlimit high enough.\n\nSet recursionlimit to something like 2 * 10**6 or maybe 1e6.\n\nNow edge cases: The input might be huge, we might want to avoid recursion due to overhead. An iterative find might be better. However we can implement recursion and it may pass. But we can also implement iterative for safety.\n\nLet's design iterative find that also returns root and compresses path:\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    # accumulate weight sum from x to root\n    root = x\n    acc = 0\n    # First find root and compute total weight\n    while parent[root] != root:\n        acc = (acc + weight[root]) % MOD\n        root = parent[root]\n    # Now acc is weight from original x to root (since we summed weights along the path)\n    # Need to compress path and update weight for each visited node.\n    # Let's collect nodes visited.\n    # Alternative: do recursion.\n    # For simplicity, we could still use recursion. It's OK.\n\nGiven constraints unknown, but typical tasks with n up to 200k recursion may be okay. So just use recursion.\n\nNow let's write final solution code accordingly.\n\n**Potential Concern: root_v variable might be overwritten after union** \n\nWhen we compute root_v = find(v), after calling find(v), parent[v] = root_v, weight[v] is depth. Then when we later do union, we set parent[root_v] = i. That's okay. But after that, if later we call find(v) again, we will compute root again with updated chain: v -> root_v (now parent root_v = i). Ok.\n\nNow we need to ensure superficial correctness: Because in union we directly set parent[root_v] = i, without checking if root_v != i (it shouldn't be). That's fine.\n\n**Potential Concern: Using parent list for both DSU and eventual tree** This DSU representation effectively stores for each vertex its \"next\" (the node towards sink) as parent. That's exactly the direction of outgoing edges (root -> child). However our DSU parent is the outgoing neighbor (child). When we set parent[root_v] = i, we are storing the edge root_v->i.\n\nNow if later a node u (which could be perhaps v) previously had parent as root_v, and then root_v gets attached to i, we need to reflect depth(u) correctly. Our find function does that.\n\nThus DSU captures exactly the forest structure.\n\n**Potential Concern: After entire process, we might want to compute depth for each node but not needed for answer. Not needed.\n\n**Potential Concern: Memory for parent and weight arrays: size n+1. Input after n may have multiple test cases? No, just one.\n\n**Potential Concern: When reading input, there may be extra whitespace after last numbers. Our parsing uses data list; it should be fine.\n\n**Potential Concern: Possibly vertices are numbered from 0? The problem says vertices are numbered by adding order: vertex i is number i. So start at 1. We'll treat as 1-indexed.\n\n**Potential Concern: Using large recursion limit may cause memory overhead, but it's fine.\n\n**Potential Concern: We must not produce extra prints. We'll only print total.\n\nNow let's craft final answer.\n\nBut the user requests: \"Please use a single tool call to submit the solution\" i.e., they want just the final code. I previously attempted something similar but they still said formatting error. Perhaps they require the \"python_code\" string be exactly the code, not with extra newline or spaces before? Possibly they want the code without any extraneous leading/trailing whitespace? Or they may be rejecting due to presence of triple quotes inside string? Actually I passed a raw multi-line string inside JSON with line breaks, but the tool maybe expects the string to be in JSON format where newlines must be escaped. However historically the system in these tasks accepts multi-line string literal directly in the chat. Something like:\n\n{\n  \"python_code\": \"import sys\\n\\nMOD = 1000000007\\n\\ndef solve():\\n    ...\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"\n}\n\nBut I think it's correct.\n\nMaybe they expect the entire solution to be placed in the \"python_code\" field, but also require that there be no top-level code besides the solve() function call? Actually they might want you to call solve() at the end. It is fine.\n\nPotential other nuance: The function name needs to be `solve()` and they call it automatically? But the problem statement: \"The script should read the input with the `input` function and print the output with the `print` function.\" So they want the script to read from stdin and print. Having a `solve()` function and then call it is fine.\n\nI think my earlier attempt includes a `if __name__ == \"__main__\": solve()` that is fine.\n\nBut the system still flagged it as incorrectly formatted. Could be because I included extra text besides the tool call (like explanation). The user says \"Please use a single tool call to submit the solution.\" So my response must contain only the tool call, nothing else. In previous attempt, I included some explanatory text prior to the tool call (the \"analysis\" channel content is not visible to user; only \"final\" channel). Actually the \"final\" channel should contain only a single tool call. In my previous response, I wrote:\n\n{\n  \"python_code\": \"... code ...\"\n}\n\nBut that was inside the \"final\" channel along with maybe preceding text. Actually I wrote:\n\n{\n  \"python_code\": \"import sys\\n\\nMOD = 1000000007\\n\\ndef solve() -> None:\\n    ...\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"\n}\n\nBut I think that is okay.\n\nBut the \"You did not format your response correctly.\" is from the system, not the user. Possibly it's because I used single quotes inside JSON? Or maybe I didn't escape newline properly. Actually the \"analysis\" channel is my internal reasoning, but the \"final\" channel should be a single tool call. In my previous response I included a code block with JSON and code. Possibly the system expects the message to be exactly a JSON with a single field \"python_code\". No extra keys or text. But historically they've accepted it. However the system says \"You did not format your response correctly.\" Possibly because I included the code block triple-backticks, which may be considered extra text.\n\nLook at earlier examples: Usually a correct submission to submit_solution is:\n\n{\n  \"python_code\": \"import sys\\n# code\\n\"\n}\n\nWithout any surrounding markdown formatting. The assistant should output a plain JSON object, not a code block.\n\nThus I need to output a raw JSON object, not in a markdown code block.\n\nThus final answer should be:\n\n{\n  \"python_code\": \"import sys\\n\\nMOD = 1000000007\\n\\ndef solve():\\n    data = list(map(int, sys.stdin.buffer.read().split()))\\n    if not data:\\n        return\\n    idx = 0\\n    n = data[idx]\\n    idx += 1\\n\\n    parent = [i for i in range(n + 1)]\\n    weight = [0] * (n + 1)\\n\\n    sys.setrecursionlimit(2 * 10**6)\\n\\n    def find(x):\\n        if parent[x] != x:\\n            p = parent[x]\\n            root = find(p)\\n            weight[x] = (weight[x] + weight[p]) % MOD\\n            parent[x] = root\\n        return parent[x]\\n\\n    total = 0\\n    for i in range(1, n + 1):\\n        parent[i] = i\\n        weight[i] = 0\\n        k = data[idx]\\n        idx += 1\\n        for _ in range(k):\\n            v = data[idx]\\n            x = data[idx + 1]\\n            idx += 2\\n            root_v = find(v)\\n            depth_v = weight[v]\\n            w = (depth_v + x) % MOD\\n            total = (total + w) % MOD\\n            parent[root_v] = i\\n            weight[root_v] = w\\n    print(total)\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"\n}\n\nMake sure there are no extra backticks or commentary.\n\nOne more nuance: I need to ensure the python code includes necessary imports and defines solve and calls it. Or we could simply write top-level code:\n\nimport sys\n\nMOD = 1000000007\n\ndef solve():\n   ...\n\nif __name__ ... \n\nThat's fine.\n\nMake sure to escape any backslashes properly.\n\nRe-check code for any syntax errors.\n\nPotential issues: `def solve():` vs `def solve() -> None:`. It's fine.\n\nMake sure indentation is correct. Use spaces not tabs.\n\nWe also need to import sys at top.\n\nNow I'll output final JSON."}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "{\n  \"python_code\": \"import sys\\nMOD = 1000000007\\ndef solve():\\n    data = list(map(int, sys.stdin.buffer.read().split()))\\n    if not data:\\n        return\\n    idx = 0\\n    n = data[idx]; idx += 1\\n    parent = [i for i in range(n + 1)]\\n    weight = [0] * (n + 1)\\n    sys.setrecursionlimit(2 * 10**6)\\n    def find(x):\\n        if parent[x] != x:\\n            p = parent[x]\\n            root = find(p)\\n            weight[x] = (weight[x] + weight[p]) % MOD\\n            parent[x] = root\\n        return parent[x]\\n    total = 0\\n    for i in range(1, n + 1):\\n        parent[i] = i\\n        weight[i] = 0\\n        k = data[idx]; idx += 1\\n        for _ in range(k):\\n            v = data[idx]; x = data[idx + 1]; idx += 2\\n            root_v = find(v)\\n            depth_v = weight[v]\\n            w = (depth_v + x) % MOD\\n            total = (total + w) % MOD\\n            parent[root_v] = i\\n            weight[root_v] = w\\n    print(total)\\nif __name__ == '__main__':\\n    solve()\\n\"\n}", "thinking": "The user repeatedly says \"You did not format your response correctly. Please use a single tool call to submit the solution.\" This suggests they want the solution code only in the `python_code` field, nothing else. The previous attempts included extra text after the code maybe? Actually the tool call format is {\"python_code\":\"...\"} as JSON. In the earlier attempts, we provided that but maybe there is an extra newline after the JSON? Or maybe the code must be exactly a string, with proper escaping? The tool call expects a JSON object with the code string. Possibly the system expects a single tool call and no other content. So we need to produce a single message that is just a tool call. The previous attempts were correct as tool calls, but perhaps they included some extra whitespace or the JSON was ill-formed? Actually the tool call is a Python function call via the interface: we need to call `submit_solution` with the code. That's what we have done. However we still get error.\n\nMaybe the problem is that there is a limit: The code must be given as a raw string without any escaped characters? Or we need to properly escape line breaks and quotes when passing as JSON. The platform expects a proper JSON string. In previous attempts, we passed a JSON object with a key python_code and value being a string that includes line breaks and quotes. That string has to be properly escaped. The tool usage likely handles that automatically. However maybe the platform expects no leading/trailing spaces in the JSON? Or expects the JSON string to be a raw block (like triple quotes)? The error \"You did not format your response correctly\" likely means the assistant's response contains extra text besides the tool call. The instructions: \"Please use a single tool call to submit the solution.\" That means the assistant's final answer should consist of just a single tool call. We must not include any additional text before or after the call. So any extra formatting like a code block around the tool call might cause it. The previous attempts included a code block with the JSON. Actually we wrote:\n\n```\n{\"python_code\": \"import sys\\n...\"}\n```\n\nBut that was inside a markdown code block (with triple backticks). That likely counts as extra text. We need to output just a plain tool call without any markdown formatting. So we must produce a message that is exactly a single JSON object with the python_code field.\n\nThus we should output (no extra context):\n\n{\n  \"python_code\": \"import sys\\nMOD = 1000000007\\n\\ndef solve():\\n    data = list(map(int, sys.stdin.buffer.read().split()))\\n    if not data:\\n        return\\n    idx = 0\\n    n = data[idx]\\n    idx += 1\\n    parent = [i for i in range(n + 1)]\\n    weight = [0] * (n + 1)\\n    sys.setrecursionlimit(2 * 10**6)\\n    def find(x):\\n        if parent[x] != x:\\n            p = parent[x]\\n            root = find(p)\\n            weight[x] = (weight[x] + weight[p]) % MOD\\n            parent[x] = root\\n        return parent[x]\\n    total = 0\\n    for i in range(1, n + 1):\\n        parent[i] = i\\n        weight[i] = 0\\n        k = data[idx]\\n        idx += 1\\n        for _ in range(k):\\n            v = data[idx]\\n            x = data[idx + 1]\\n            idx += 2\\n            root_v = find(v)\\n            depth_v = weight[v]\\n            w = (depth_v + x) % MOD\\n            total = (total + w) % MOD\\n            parent[root_v] = i\\n            weight[root_v] = w\\n    print(total)\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"\n}\n\nWe must ensure it's valid JSON: The python_code string should escape double quotes inside. In our code we have double quotes for the module doc? Actually we used double quotes for the __main__ check: if __name__ == \"__main__\":. The string is enclosed in double quotes, but there are double quotes inside, these need to be escaped as \\\". However the tool call probably expects raw string, not manually escaped? The platform probably takes care of that when we pass a string value. In our previous attempts we used triple quotes? Actually we wrote:\n\n{\n  \"python_code\":\"import sys\\nMOD = 1000000007\\ndef solve():\\n    ...\\n\"\n}\n\nThat's fine. Inside code there are double quotes around \"__main__\". But those double quotes need to be escaped; but the interface may accept raw string automatically? The earlier attempts contain those double quotes raw in JSON--maybe the system automatically escapes them? I'm not sure.\n\nBetter to avoid double quotes inside code; we can use single quotes for string literals; then we avoid escaping. Let's modify code accordingly: Use single quotes in string literals (like '__main__') and also maybe imports use no quotes. So final code with minimal internal double quotes.\n\nThus the code:\n\nimport sys\nMOD = 1000000007\ndef solve():\n    data = list(map(int, sys.stdin.buffer.read().split()))\n    if not data:\n        return\n    idx = 0\n    n = data[idx]; idx += 1\n    parent = [i for i in range(n + 1)]\n    weight = [0] * (n + 1)\n    sys.setrecursionlimit(2 * 10**6)\n    def find(x):\n        if parent[x] != x:\n            p = parent[x]\n            root = find(p)\n            weight[x] = (weight[x] + weight[p]) % MOD\n            parent[x] = root\n        return parent[x]\n    total = 0\n    for i in range(1, n + 1):\n        parent[i] = i\n        weight[i] = 0\n        k = data[idx]; idx += 1\n        for _ in range(k):\n            v = data[idx]; x = data[idx + 1]; idx += 2\n            root_v = find(v)\n            depth_v = weight[v]\n            w = (depth_v + x) % MOD\n            total = (total + w) % MOD\n            parent[root_v] = i\n            weight[root_v] = w\n    print(total)\nif __name__ == '__main__':\n    solve()\n\nNow we need to embed this as a JSON string. All double quotes inside code now only used for the JSON quoting delim. There are single quotes only; no double quotes inside code. Also we must ensure that we escape newline characters? Actually we provide raw string with actual newline characters. The JSON string must include newline characters as literal \\n? Usually JSON string cannot contain literal line breaks; they must be escaped as \\n. However the tool call likely expects a raw string value that may contain actual newline characters; but in JSON format, newline needs to be escaped. However the tool interface likely handles the conversion automatically. The prior attempts included raw line breaks within the string as we wrote them; they ended up as raw line breaks inside the JSON in the message? Actually we wrote:\n\n{\n  \"python_code\": \"import sys\\nMOD = 1000000007\\n\\ndef solve():\\n    ...\\n\"\n}\n\nThis has literal \\n escaped as \\n in the string: That's correct. The interface likely interprets that as a string with newlines. In our previous attempts, we included line breaks as actual newlines inside the code block, not as \\n escapes. That may have broken JSON. Indeed we need to provide the JSON with actual newline characters encoded as \\n. Using triple quotes in the assistant message may have produced actual line breaks, not \\n. The tool probably expects JSON string with proper escaping. However maybe the tool automatically handles raw string as a Python string in the response; but I think we need to provide a JSON object as a plain text with proper escaping. The best approach: Just output a JSON object with newline characters encoded as `\\n`. We'll produce the code as a single string with \\n and also double quotes inside code replaced.\n\nThus final answer: plain text starting with { \"python_code\":\"...\"}.\n\nMake sure not to include any markdown fences or commentary. We'll produce exactly one line or multiple lines, but not include any extra characters outside JSON.\n\nWill this be accepted? Let's try.\n\nWrite the JSON:\n\n{\n  \"python_code\":\"import sys\\nMOD = 1000000007\\ndef solve():\\n    data = list(map(int, sys.stdin.buffer.read().split()))\\n    if not data:\\n        return\\n    idx = 0\\n    n = data[idx]; idx += 1\\n    parent = [i for i in range(n + 1)]\\n    weight = [0] * (n + 1)\\n    sys.setrecursionlimit(2 * 10**6)\\n    def find(x):\\n        if parent[x] != x:\\n            p = parent[x]\\n            root = find(p)\\n            weight[x] = (weight[x] + weight[p]) % MOD\\n            parent[x] = root\\n        return parent[x]\\n    total = 0\\n    for i in range(1, n + 1):\\n        parent[i] = i\\n        weight[i] = 0\\n        k = data[idx]; idx += 1\\n        for _ in range(k):\\n            v = data[idx]; x = data[idx + 1]; idx += 2\\n            root_v = find(v)\\n            depth_v = weight[v]\\n            w = (depth_v + x) % MOD\\n            total = (total + w) % MOD\\n            parent[root_v] = i\\n            weight[root_v] = w\\n    print(total)\\nif __name__ == '__main__':\\n    solve()\\n\"\n}\n\nThat should be valid JSON (the string includes \\n). It uses double quotes outer and inner. It includes single quotes only inside code, which is okay. However there are double quotes inside code? There's no double quote inside code now because we replaced __main__ with single quotes. Also there are no other double quotes. Does the string contain any unescaped backslashes? We have `\\n` which is fine. The backslash for newline must be escaped as `\\\\n`? Actually in JSON, a newline is represented literally as `\\n` (two characters: backslash and n). In our text we typed `\\n`. That's correct. However we also have other backslashes? Not needed.\n\nThus final answer: just the JSON line."}]