[{"role": "system", "content": "You are a very competent coder.<|im_end|><|im_system|>tool_declare<|im_middle|>[{\"function\":{\"description\":\"Call this tool to submit the solution python code.\",\"name\":\"submit_solution\",\"parameters\":{\"properties\":{\"python_code\":{\"type\":\"str\"}},\"required\":[\"python_code\"],\"type\":\"object\"}},\"type\":\"function\"}]"}, {"role": "user", "content": "Please solve the following programming problem. Please use tool calls to output the solution.\nThe script should read the input with the `input` function and print the output with the `print` function.\nNote that the solution would be run as is, so you must NOT print anything other than the expected output. Namely, do NOT use debug prints and do not write demos.\n\nYou are given n points on a plane. All points are different.\n\nFind the number of different groups of three points (A, B, C) such that point B is the middle of segment AC.\n\nThe groups of three points are considered unordered, that is, if point B is the middle of segment AC, then groups (A, B, C) and (C, B, A) are considered the same.\n\n\n\n"}, {"role": "assistant", "content": "<think>We need to solve a problem: Given n points (distinct), find number of unordered triples (A, B, C) such that B is the midpoint of segment AC. Unordered means that (A, B, C) is same as (C, B, A). However, (A, B, C) and (B, A, C) etc? Let's interpret: The group of three points is unordered, but condition B is the middle of segment AC. So B must be the midpoint, but the ordering within the triple is irrelevant. Usually, for such problems, the triple is considered as a set of three points, but the condition picks out which point is the midpoint: B is the midpoint of segment connecting the other two points. So for a given unordered triple {A, B, C}, if either A, B, or C could be the midpoint of the segment formed by the other two, we need to count each case separately? The problem statement: \"Find the number of different groups of three points (A, B, C) such that point B is the middle of segment AC. The groups of three points are considered unordered, that is, if point B is the middle of segment AC, then groups (A, B, C) and (C, B, A) are considered the same.\" So essentially they consider (A,B,C) as ordered triple with B being the designated midpoint; but they treat swapping A and C as same group. So basically we count each unordered pair (A, C) where B is midpoint of A and C. For each midpoint B, you could have many pairs A, C such that B is midpoint. So total count = sum over B of number of unordered pairs (A, C) such that B is midpoint. Since swapping A and C yields same group, each unordered pair counts once. So we count each pair {A, C} once.\n\nThus we need to count for each point B, number of unordered pairs (A, C) where (A + C) / 2 = B (vector addition). Equivalent to A + C = 2B. So for each B, we need to count number of unordered pairs (A, C) among the set of points (excluding B? Actually A and C can be B? The condition \"point B is the middle of segment AC\" usually implies A and C distinct from B. Usually points are distinct, but B may equal A or C? No, if B is the midpoint of segment AC, then A and C must be symmetric around B. If B coincides with A, then the segment would be degenerate? Let's examine. If A = B, then B is the midpoint of segment AC implies B = (A + C) / 2 => B = (B + C)/2 => 2B = B + C => B = C => all three points coincide. But all points are distinct, so not allowed. Hence A, C must be distinct from B. So we consider pairs (A, C) where A and C are distinct from each other and from B.\n\nThus we need to count for each B, the number of unordered pairs (A, C) among the other points with coordinates summing to 2B.\n\nApproach: Use a dictionary mapping from vector (x, y) to count of points with those coordinates. Since points are distinct, each coordinate appears once, but multiple points may share same coordinates? The problem says \"All points are different.\" That usually means distinct points, i.e., no duplicate points. So each coordinate appears exactly once.\n\nGoal: For each point B, we consider all other points A. Then C = 2B - A. We need to check if C is also a point in the set, distinct from A and B. Then each unordered pair (A, C) will be counted twice (once when iterating A as the first point, and C also appears as other) unless we enforce ordering like only count when A < C (some ordering) to avoid double counting. But we also need to avoid double counting across B's? Actually each triple (A, B, C) with B as midpoint is counted once for the specific B; there is no double counting across different B because B is uniquely determined as the midpoint of A and C (the midpoint of a segment is unique). So each unordered pair (A, C) yields at most one B. So we can just count all unordered pairs (A, C) and then identify B as the midpoint. However we need to ensure we count each triple exactly once. The easiest approach: Iterate over all unordered pairs (A, C). Compute midpoint M = ((x_A + x_C)/2, (y_A + y_C)/2). If M has integer coordinates? Actually coordinates can be any real numbers? Points are given as coordinates (likely integers). If coordinates are integers, the midpoint may be integer or half-integer. For B to be a point in the set, its coordinates must match a given point. So M must be exactly equal to some point B in the set. Then we have a valid triple. Count it. Since we consider unordered pairs (A, C), each triple will be counted exactly once. Complexity: O(n^2) which might be okay for n up to maybe 2000? But we don't know constraints. Could be up to 2000 or maybe 5000, which yields about 12.5 million pairs, which is okay. Could be up to 10^5, which would be too large for O(n^2). Need to think about more efficient solution.\n\nWe need to infer constraints from typical programming problem. There's a known problem: \"Points and Midpoints\" or \"Count the number of triples where one point is midpoint of the other two.\" Usually constraints are up to n <= 2000 or maybe 5000, O(n^2) is okay. Could be up to 10^5 with coordinates up to 10^9 requiring O(n log n) or O(n) with hash maps. Actually we can solve in O(n) expected time using hashing: For each unordered pair (A, C), compute M = (A + C) / 2. But we can just compute for each B, count number of unordered pairs (A, C) satisfying A + C = 2B. That's like for each B, we need to count number of pairs of points (excluding B) that sum to 2B. This is similar to two-sum problem: For a fixed B, we have target vector T = 2B. We need to count number of unordered pairs (A, C) among the set such that A + C = T. Since we have distinct points.\n\nWe can do this by using a frequency map of vectors. Since points are distinct, each coordinate appears once, but we need to count pairs of points distinct from B and each other. We could do: For each B, iterate through all other points A (n-1 of them) and compute C = T - A = 2B - A. Then check if C is in the set. We need to count each unordered pair only once. We could do something like: For each B, maintain a set of visited points for this B (or use global ordering). But we can also just count all ordered pairs (A, C) where A != C and both not equal to B, then divide by 2 (since each unordered pair appears twice: (A, C) and (C, A)). However we need to ensure we don't count pairs where C = A (i.e., 2A = T => A = B). But since A != B, that can't happen because if 2A = 2B => A = B. So not a problem.\n\nThus for each B, we can count number of (ordered) pairs (A, C) with A != B, C != B, A + C = 2B. Since we will consider all A != B and compute C = 2B - A; if C is in the set of points (including possibly B?), but we need C != B. If C = B then the pair (A, C) would be (A, B) and B is the midpoint of A and B? Let's check: If C = B, then we need A + B = 2B => A = B, which contradicts distinctness. So C cannot be B if A != B. So we can ignore that. So if C is present in the set of points, then ordered pair (A, C) counts. For each unordered pair {A, C}, both ordered pairs (A, C) and (C, A) will be counted when we iterate A over each of the two points. So total ordered count per B is twice the number of unordered pairs. So number of unordered pairs = ordered_count / 2.\n\nThus for each B we can do: For each A != B, compute C = 2B - A. If C is in the set of points (including B?), then increment count. Then after finishing loop, divide by 2. Complexity: O(n^2) worst-case. But we can optimize using hashing: For each B, we need to count pairs of points (excluding B) that sum to a target. This is similar to counting pairs of numbers that sum to a given target, which can be done in O(n) per B by building a hash set of points and then for each point A (excluding B) checking if complement exists. That's still O(n^2). However, perhaps we can do overall O(n^2) anyway.\n\nBut maybe we can find a more efficient algorithm: Use a dictionary counting vectors (points). Since points are unique, we can map each point to its index. Then for each unordered pair (A, C), compute M = (A + C) / 2; if M is integer (i.e., both sums are even) and M exists in the dictionary, then we have a triple. The total number of unordered pairs is n*(n-1)/2, which is O(n^2). So we can't avoid O(n^2) if we need to consider all pairs. But maybe we can reduce by using geometry: If we group points by x or y coordinate? Not obvious.\n\nGiven typical contest constraints, O(n^2) might be okay for n up to 2000 or maybe 5000. But in Python, 5000^2 = 25 million, which is acceptable. 10,000^2 = 100 million, which might be borderline but still maybe okay if optimized with simple integer arithmetic and dictionary lookups (maybe ~0.1 micro per op). Might be okay for 2 seconds? Might be borderline. Usually for n up to 3000, O(n^2) is safe.\n\nBetter approach: Use sorting and binary search? Not helpful.\n\nAlternative: Use vector frequency and treat each pair as sum. There's known technique: For each point B, we can count number of pairs (A, C) where A + C = 2B by using a frequency map of vectors after subtracting B? Actually we can treat points as vectors. For each B, we want to count number of unordered pairs among the set of points (excluding B) whose sum equals 2B. If we shift coordinates by subtracting B, we get new set of vectors V_i = P_i - B for each point P_i != B. Then we need to count unordered pairs (V_i, V_j) such that V_i + V_j = 0 (i.e., V_j = -V_i). So basically count number of pairs of opposite vectors in the set V. That's just counting pairs of points symmetric around B. So for each B, we need to count number of pairs of points that are symmetric with respect to B.\n\nThus we can do: For each B, create a dictionary of transformed points (P_i - B) for i != B. Then count frequency of each vector. For each vector v, if -v also exists, then number of pairs contributed is freq(v) * freq(-v) if v != -v, else freq(v) choose 2. Summing over all v gives total ordered pairs? Actually each unordered pair (A, C) corresponds to opposite vectors v and -v. If v != -v, then each unordered pair corresponds to one vector v (with A) and its opposite C. Counting freq(v) * freq(-v) counts each unordered pair twice? Let's see: Suppose we have vectors v and -v. For any pair (A, C) where A - B = v and C - B = -v, that's a valid pair. The number of such unordered pairs is freq(v) * freq(-v). Since we consider unordered pairs, this product counts each unordered pair exactly once (choose a point from the v group and a point from the -v group). However, when later we consider v = -v (i.e., v = 0 vector), then points are B itself, which is excluded. So we don't need that. But careful: After we compute total unordered pairs for B, we need to ensure we count each unordered pair only once; the product freq(v) * freq(-v) for each v does that, but we might double count when we later also consider -v as a separate v in the dictionary iteration. For example, if we iterate over all v in the dictionary, for each v we can add freq(v) * freq(-v) and then we would count each unordered pair twice (once for v and once for -v). To avoid double counting, we can only consider each pair of opposite vectors once, e.g., only for v where some ordering like v < -v (lexicographic) or only count half of them. Or we can compute total ordered pairs: For each A (i.e., each vector v), check if -v is present; if so, count that as an ordered pair (A, C) where C corresponds to -v. That yields ordered count = sum over all vectors v of freq(v) * freq(-v). Since each unordered pair appears twice (once for v and once for -v). So unordered pairs = ordered_count / 2.\n\nThus for each B we could compute using frequency dictionary of vectors (P_i - B) for i != B. Then unordered pairs = sum_{v} freq(v) * freq(-v) / 2. But we need to be careful not to double count across B's. However each unordered pair (A, C) will be counted only for the B that is the midpoint of A and C. Since for each pair we could compute B = (A + C) / 2. If B is a point present in the set, then the pair will show up for that B. So each valid triple counted exactly once irrespective of method. So we can just sum over B the unordered pairs computed as above, but ensure we aren't double counting within B's calculation.\n\nSimplify: Use global set/dict of points. For each ordered pair (A, C) where A != C, compute B = (A + C) / 2. If B exists in the set and (A != B) and (C != B) (which is automatically true if they are distinct) then we can increment a counter, but we need to consider unordered triples only once. Since ordered pairs (A, C) and (C, A) both correspond to same unordered triple, we can just restrict to A < C (by index) and count only those, dividing by 2. So final answer = number of unordered pairs (A, C) with A < C such that midpoint exists in the set.\n\nImplementation details: Since points might have large integer coordinates (maybe up to 10^9), but we can store them as tuples of ints.\n\nWe need to read n, then read n lines each with x and y.\n\nConstraints unknown, but typical tasks have n up to maybe 2000 or maybe 10^5. O(n^2) is okay for 2000 but not for 10^5. However O(n^2) for 10^5 is 10^10, not feasible. Perhaps there is a more efficient method using combinatorial hashing? Let's think.\n\nPotentially we can solve in O(n log n) using a map of frequencies of vectors and then for each pair of points produce the midpoint. The number of possible distinct midpoints among n points is O(n^2), can't be less. But we only care when midpoint coincides with a given point. So we need to determine for each point B, count pairs (A, C) with A + C = 2B. That's reminiscent of counting the number of \"2-sum\" pairs for each target 2B among the list of points. This can be done using FFT-based convolution? Not straightforward for 2D vectors.\n\nAlternatively, we can treat each coordinate separately: For a pair (A, C) to have integer midpoint B (i.e., B is a point in set), we need x_A + x_C = 2 x_B and y_A + y_C = 2 y_B. So each coordinate must satisfy same parity: both x_A + x_C must be even (if coordinates are integers). If points can be arbitrary integers, then the sum must be even for the midpoint to have integer coordinates; but B may have integer coordinates because given point has integer coordinate. So if points have integer coordinates, the sum of two integers must be even; i.e., x_A and x_C must have same parity. Similarly for y. So we could split points by parity classes: (x parity, y parity) combos. There are 4 classes: (even, even), (even, odd), (odd, even), (odd, odd). For each class, any pair of points within the same class produce integer midpoint. Then we only need to count such pairs whose midpoint belongs to the set. However there may still be many pairs. But we can further group points by something else.\n\nAnother perspective: This is similar to counting number of collinear triples with one point being midpoint, which is known as counting \"center-symmetric\" sets: given a set of points, we need to count the number of \"centered\" pairs for each point.\n\nWe might try to use a hashmap of vectors for each point as described; O(n^2) worst-case but maybe average less.\n\nLet's check typical problem statements: \"You are given n points on a plane. All points are different. Find the number of different groups of three points (A, B, C) such that point B is the middle of segment AC. The groups of three points are considered unordered...\" Usually this is from a contest like Codeforces or acmp. Might be a known problem \"C. Midpoint\" or something.\n\nSearch memory: I recall a problem \"C. Midpoint\" perhaps from Codeforces Round # (Div2). Solutions used a map of points and O(n^2) loops. Let's think: Many solutions used sets: put all points into a set for O(1) lookups. Then they loop over all unordered pairs (i < j), compute the midpoint: if (x_i + x_j) % 2 == 0 and (y_i + y_j) % 2 == 0 and ((x_i + x_j) // 2, (y_i + y_j) // 2) in the set, then increment answer. That's O(n^2). Usually constraints were up to maybe 3000 or 5000. Implementation uses 64-bit ints.\n\nAlternative: If n up to 2000, then O(n^2) is fine.\n\nThus an O(n^2) solution is acceptable.\n\nEdge Cases: Points may be far apart, but using Python's int is fine.\n\nCounting: Since we need to count unordered triples, each valid pair (i, j) yields exactly one triple because the midpoint is unique. But we must ensure we don't double count when there are multiple points that can serve as midpoints? Actually a triple may have more than one possible midpoint? For three points distinct, can there be both B is midpoint of AC and also A is midpoint of BC? Let's examine geometry: For three distinct points, it's possible that each point is the midpoint of the segment formed by the other two? No. If we have points A, B, C collinear and B is between A and C and AB = BC, then B is midpoint of AC. If also C is midpoint of AB? That would require AC = CB? Not possible because AC = AB + BC = 2*AB, but for C to be midpoint of AB, we need A + B = 2C. But if B is midpoint of AC then A + C = 2B. Solve these two equations: A + C = 2B, A + B = 2C => subtract: (A + C) - (A + B) = 2B - 2C => C - B = 2(B - C) => C - B = -2(C - B) => 3(C - B) = 0 => C = B. So they'd be same point, contradiction. So each triple can have at most one midpoint. So counting each unordered pair (i,j) where midpoint in set yields exactly one valid triple, no overcount.\n\nThus answer = count of unordered pairs (i, j) (i < j) such that midpoint exists in the set and i, j, and midpoint are distinct (which holds automatically because set contains distinct points). However, need to ensure that the midpoint is not equal to i or j. If i and j are symmetric about B, B cannot be equal to i or j unless i=j, but they are distinct. So ok.\n\nThus algorithm: read points into list and set for O(1) lookups. Use a set of (x, y) tuples. Then loop i from 0 to n-1, j from i+1 to n-1. Compute xs = x_i + x_j, ys = y_i + y_j. If xs % 2 != 0 or ys % 2 != 0, skip. Else compute xm = xs // 2, ym = ys // 2. If (xm, ym) in point_set, then increment answer.\n\nReturn answer.\n\nComplexities: O(n^2) time, O(n) memory.\n\nPotential pitfalls: Might overflow in other languages, but Python int unlimited.\n\nPotential large n: If n up to 50000, O(n^2) = 2.5 billion loops too many. So maybe problem expects O(n^2) with small n (<5000).\n\nCheck time: 5000^2 = 25 million loops, each performing a few integer ops and a set lookup. Might be ~0.2-0.3 seconds per million? In Python maybe 0.2 sec per million simple ops, so 25 million ~5 seconds maybe. Might be borderline but still could pass with pypy.\n\nBut we can also optimize: Use integer arithmetic and local variables, use set lookup which is fast.\n\nWe can also store points in a list of tuples of ints.\n\nBetter to use PyPy for speed.\n\nWe can also partly vectorize: For each i, we consider j > i; computing sums. Could we use sorting by something to reduce? Possibly we can group points by parity to reduce loops: For each parity class, we only need to consider pairs within same class. That's a factor of 4 reduction (since there are 4 parity classes). So we can pre-group points into 4 lists by parity of x and y. Then do nested loops within each group, reducing running time to ~n^2/4. That's helpful.\n\nImplementation steps:\n\n- Read n.\n- Initialize a dictionary mapping parity tuple (px, py) to a list of points.\n- For each point (x, y), compute parity (x & 1, y & 1) (i.e., x%2, y%2) and append point to appropriate list.\n- Also add point to point_set for quick lookups.\n\n- ans = 0.\n\n- For each parity group g, points_list = groups[g].\n  - For i from 0 to len(points_list)-1:\n    - x_i, y_i = points_list[i]\n    - For j from i+1 to len(points_list)-1:\n      - x_j, y_j = points_list[j]\n      - xs = x_i + x_j; ys = y_i + y_j\n      - xm = xs >> 1; ym = ys >> 1 (since xs and ys are even due to same parity)\n      - If (xm, ym) in point_set: ans += 1\n\nWe could verify parity: Since both points have same parity where x_i %2 == x_j%2 and y_i%2 == y_j%2, sum will be even, so integer division fine.\n\nBut caution: x_i + x_j may be odd if both have same parity? Actually if both have parity p (0 or 1), sum = 2p + even => even. So yes always even.\n\nThus we can avoid mod check.\n\nBut we must be careful: Points may have non-integer coordinates? Usually they are integers. The problem does not specify that coordinates are integers. However typical input problems use integer coordinates. If they could be arbitrary real numbers, then parity check meaningless. But we can't check existence of midpoint in set using division if coordinates can be fractional. However typical contest problems use integer coordinates.\n\nLet's check the statement: \"You are given n points on a plane. All points are different.\" Usually they provide integer coordinates in input. So we assume integer coordinates.\n\nThus algorithm stands.\n\nNow, we need to implement solve() reading from input and printing answer.\n\nEdge Cases:\n\n- n < 3 => ans = 0 because no triples.\n\n- If there are many points, set will be large.\n\n- The answer can be large: e.g., n=2000, each triple counted maybe many. Could be up to O(n^3) worst-case? Actually maximum triples where each B is midpoint for many pairs? Suppose all points are arranged in a grid with many collinear lines? The maximum number of unordered pairs with a given midpoint could be O(n) for each B? Actually if we have all points in a line equally spaced the endpoints pairs share same midpoint perhaps many? Actually for each B, pairs (A, C) with B as midpoint correspond to selecting two points symmetric around B. So number of such pairs is k choose 2 where k is number of points on each side? Let's find maximum possible answer: For each point B, number of unordered pairs with midpoint B is at most floor(m/2) choose something? Actually maximum occurs when points are arranged like a \"balanced\" set: each point B can be paired with many pairs. If point set is of size n and all points are on a line with equal spacing, then each point except extremes can be midpoint of many pairs: For B at position i (0-indexed), there are min(i, n-1-i) pairs symmetric about i (choose a point left and right at equal distance). So total number of triples is O(n^2). So answer fits within 64-bit integer: at most n*(n-1)/2 maybe. Actually maximum answer cannot exceed number of unordered pairs of distinct points, which is n*(n-1)/2, because each unordered pair yields at most one midpoint triple (if the midpoint exists as a point). So answer <= n*(n-1)/2. For n up to 10^5, answer can be ~5e9, fits in 64-bit (<2^63). So Python int is fine.\n\nNow, test manually with small examples.\n\nExample: n=3 points (0,0), (1,1), (2,2) all collinear. Midpoint of (0,0) and (2,2) is (1,1) which is a point. So answer should be 1. Our algorithm: points_set contains all three. For each unordered pair (i<j): (0,0)-(1,1): sum (1,1) -> midpoint (0.5,0.5) not integer, skip? Actually sum is 1,1 -> not both even, skip. (0,0)-(2,2): sum (2,2) -> midpoint (1,1) present => ans=1. (1,1)-(2,2): sum (3,3) -> not integer, skip. So ans=1, correct.\n\nAnother example: points (0,0), (2,0), (1,0), (3,0), (5,0). Let's see possible triples: (0,0)-(2,0) midpoint (1,0) => yes. (0,0)-(4,0) but 4 not there. (1,0)-(3,0) midpoint (2,0) => yes. (2,0)-(4,0) no. (0,0)-(6,0) no. (1,0)-(5,0) midpoint (3,0) => yes. (3,0)-(5,0) midpoint (4,0) not present. So total 3. Our algorithm: parity grouping: all points have even parity? Actually x parity: 0,2,1,3,5 -> mixture. Group by parity classes: (0,0) (2,0) both x even; (1,0) (3,0) (5,0) x odd, y even. So loops within each group will find pairs. For group even: (0,0)-(2,0) sum (2,0) -> midpoint (1,0) present => ans++ (makes 1). Group odd: points (1,0),(3,0),(5,0). Pair (1,0)-(3,0) -> sum (4,0) -> midpoint (2,0) present => ans++ (2). Pair (1,0)-(5,0) -> sum (6,0) -> midpoint (3,0) present => ans++ (3). Pair (3,0)-(5,0) -> sum (8,0) -> midpoint (4,0) not present => no increment. So ans=3 correct.\n\nAnother test: points (0,0), (1,1), (2,2), (3,3). Triples: (0,0)-(2,2) midpoint (1,1) => yes. (1,1)-(3,3) midpoint (2,2) => yes. (0,0)-(3,3) midpoint (1.5,1.5) not integer, not a point. (0,0)-(1,1) no. (2,2)-(3,3) no. (1,1)-(2,2) no. So total 2. Our algorithm: parity grouping: (0,0),(2,2) both even-even; (1,1),(3,3) both odd-odd. Group even-even: (0,0)-(2,2) sum (2,2) -> midpoint (1,1) present => ans=1. Group odd-odd: (1,1)-(3,3) sum (4,4) -> midpoint (2,2) present => ans=2.\n\nWorks.\n\nNow consider non-integer coordinates or rational coordinates? If coordinates can be any integer or maybe real? If coordinates can be negative? Parity grouping works only for integer coordinates. If coordinates can be negative, parity using modulo 2 works similarly in Python: negative %2 yields either 0 or 1? Actually -1 %2 = 1. So parity classification holds. Actually we want parity of integer coordinates; but sum of two numbers with same parity always even, even for negative numbers: e.g., -3 and -1 both odd, sum -4 even. So integer division //2 yields -2 correctly: -3 + -1 = -4, //2 = -2, which is correct. So fine.\n\nPotential problem: Use // for negative numbers? If sum is negative and even, //2 yields correct floor division? Actually -4 //2 = -2. Good. If sum is negative and odd? But we only consider sums that are even; but due to parity classification we guarantee even. So it's fine.\n\nNow need to ensure we handle input reading correctly. Input format unspecified. Usually first line contains integer n. Then n lines follow each with two integers x y. Could also be all numbers separated by whitespace arbitrarily. We'll read all via sys.stdin.read().split().\n\nImplementation details:\n\n```\ndef solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    points = []\n    point_set = set()\n    # groups by parity of x and y\n    groups = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n        point_set.add((x, y))\n        parity = (x & 1, y & 1)\n        groups[parity].append((x, y))\n    ans = 0\n    # For each parity group\n    for group in groups.values():\n        m = len(group)\n        # nested loops\n        for i in range(m):\n            x_i, y_i = group[i]\n            for j in range(i+1, m):\n                x_j, y_j = group[j]\n                # Since parity matches, sum is even\n                xm = (x_i + x_j) >> 1\n                ym = (y_i + y_j) >> 1\n                if (xm, ym) in point_set:\n                    ans += 1\n    # print answer\n    sys.stdout.write(str(ans))\nif __name__ == \"__main__\":\n    solve()\n```\n\nTesting for small examples.\n\nWe need to ensure it works for cases where n < 3 (no groups). loops will produce ans=0.\n\nTime complexity: Sum over groups of (size_g^2). Since sum size_g = n, worst-case when each group size ~ n/4, then total loops is approx 4 * (n/4 choose 2) = approximately n^2/8 - something. So half of naive O(n^2). Actually naive O(n^2) loops n*(n-1)/2 pairs; parity grouping reduces loops to sum_g (size_g*(size_g-1)/2). This is at most total pairs across groups. The worst-case scenario (points evenly distributed across groups) yields roughly n^2/8 vs n^2/2. So about 1/4 of naive. So it reduces constant factor.\n\nOne could also group by other invariants like (x mod 2, y mod 2) as we did.\n\nPotential further reduction: If coordinates can be large, sets are okay.\n\nAlternative: Use integer arithmetic rather than tuple for set key for potential speed: encode as int by packing bits: e.g., (x << 32) ^ (y & 0xffffffff) but not necessary.\n\nOne potential issue: Memory usage for point_set is O(n). That's fine.\n\nNow, discuss necessary modifications if coordinates can be non-integer. Then the parity trick fails; we need to check if midpoint is integer? Actually if coordinates not integer, we can't have parity, but we need to test if midpoint exists in set exactly. For non-integer coordinates, we need to check if (x_i + x_j) / 2 and (y_i + y_j) / 2 equal some point's coordinates exactly. Since floats equality is tricky, but if coordinates are rational numbers maybe expressed as fractions? Usually input uses integers.\n\nThus we can keep as is but we need to also check parity maybe not needed if we store points as floats? Actually we need to compute exact midpoint using integer division only if sum is even; else midpoint not integer. However, for integer coordinates, if sum is odd, the midpoint is not an integer point, thus can't be present among integer-coordinate points. So we can skip.\n\nThus algorithm enumerates only pairs within same parity class to guarantee sum even; but consider a case where x_i and x_j have different parity but the midpoint may still be integer? No, sum of an even and odd is odd; dividing by 2 yields non-integer (.5). So can't be a point with integer coordinates. So skip.\n\nThus grouping by parity also ensures we only consider pairs that could produce integer midpoint. This eliminates many pairs and saves time.\n\nPotential scenario: Input coordinates could be non-integers (like floating point numbers). The problem likely uses integers. So okay.\n\nNow test with random points.\n\nTest 1: n=0? Not possible maybe. n positive.\n\nLet's run some mental tests.\n\nTest: n=1: no triples. code: groups will have one point; loops with m=1 -> no pairs; ans=0.\n\nTest: n=2: no triples.\n\nTest: n=3 with points not collinear: (0,0), (0,1), (1,0). None of any pair's midpoint is a point in the set: (0,0)-(0,1) -> (0,0.5) not int; (0,0)-(1,0) -> (0.5,0); (0,1)-(1,0) -> (0.5,0.5). So ans=0.\n\nTest: n=3 with points (0,0),(2,0),(1,0): we get ans=1.\n\nTest: n=4 with points (0,0), (2,0), (4,0), (2,0)? That's duplicate not allowed. Let's create (0,0),(2,0),(4,0),(6,0). Triples: (0,0)-(2,0) midpoint (1,0) not present. (0,0)-(4,0) midpoint (2,0) present, count++. (0,0)-(6,0) midpoint (3,0) not present. (2,0)-(4,0) midpoint (3,0) not. (2,0)-(6,0) midpoint (4,0) present, count++. (4,0)-(6,0) midpoint (5,0) not. So ans=2. Our algorithm: parity groups: all x even, y even. pairs: (0,0)-(2,0) sum (2,0) -> midpoint (1,0) not in set. (0,0)-(4,0) -> (2,0) -> (2,0) present -> ans++ (1). (0,0)-(6,0) -> (3,0) not. (2,0"}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "", "thinking": "The user wants me to format the response as a single tool call to submit the solution. I need to produce the final code as a string inside a JSON structure for the `submit_solution` tool.\n\nThus, I need to write a Python solution according to the problem description, reading input from stdin and printing the answer. I should not include any extra debug prints or text. The code should be self-contained, likely with a `solve()` function and call it.\n\nI'll include the parity grouping optimization, but maybe I could also just do a straightforward O(n^2) loops with parity check; either is fine. Let's implement the grouping approach for efficiency.\n\nI need to be mindful to read all integer inputs and handle cases where n may be zero (though not typical). Also, use `sys.stdin.read` for speed.\n\nThe answer should be printed as integer.\n\nThus final code:\n\n```python\nimport sys\n\ndef solve():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    points = []\n    point_set = set()\n    groups = {(0,0): [], (0,1): [], (1,0): [], (1,1): []}\n    for _ in range(n):\n        x = int(next(it))\n        y = int(next(it))\n        points.append((x, y))\n        point_set.add((x, y))\n        parity = (x & 1, y & 1)\n        groups[parity].append((x, y))\n    ans = 0\n    for group in groups.values():\n        m = len(group)\n        for i in range(m):\n            xi, yi = group[i]\n            for j in range(i + 1, m):\n                xj, yj = group[j]\n                # since parity matches, sums are even\n                xm = (xi + xj) >> 1\n                ym = (yi + yj) >> 1\n                if (xm, ym) in point_set:\n                    ans += 1\n    sys.stdout.write(str(ans))\n\nif __name__ == \"__main__\":\n    solve()\n```\n\nThat's the code.\n\nNow I need to respond with a tool call as required.\n\nThe tool name is `submit_solution` and it takes a single parameter `python_code` which is the code string.\n\nThus output:\n\n{\n  \"python_code\": \"... code ...\"\n}\n\nNeed to ensure proper JSON formatting with double quotes, escaping newline characters? The tool expects a string containing the python code. It will handle raw string, I need to embed the code as a JSON string. Thus I must produce a valid JSON string: basically a multi-line string with \\n for newlines. I'll include the code as is.\n\nThus final answer: a JSON with python_code.", "tool_calls": [{"type": "function", "id": "functions.submit_solution:0", "function": {"name": "", "arguments": "{\"python_code\": \"import sys\\n\\ndef solve():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    it = iter(data)\\n    n = int(next(it))\\n    point_set = set()\\n    groups = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\\n    for _ in range(n):\\n        x = int(next(it))\\n        y = int(next(it))\\n        point_set.add((x, y))\\n        parity = (x & 1, y & 1)\\n        groups[parity].append((x, y))\\n    ans = 0\\n    for group in groups.values():\\n        m = len(group)\\n        for i in range(m):\\n            xi, yi = group[i]\\n            for j in range(i + 1, m):\\n                xj, yj = group[j]\\n                # Since both points have the same parity, (xi + xj) and (yi + yj) are even.\\n                xm = (xi + xj) >> 1\\n                ym = (yi + yj) >> 1\\n                if (xm, ym) in point_set:\\n                    ans += 1\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"}"}}]}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "", "thinking": "The user is complaining that I didn't format my response correctly. The instruction says \"Please use a single tool call to submit the solution.\" I previously made a tool call to submit_solution with the Python code. That should be correct. However, maybe the user didn't see it as a single tool call? Perhaps they want only the tool call, without any extra text? The instruction says: \"Please use a single tool call to submit the solution.\" I should output only the tool call and nothing else (no extra explanation). However my last response included the tool call but also explanation. Let me check the content. I said:\n\n```\nI need to solve the problem. The key observation is that... (explanation). Then I submitted the solution code via tool call...\n```\n\nBut the user wants the response to consist solely of a tool call. Actually the instructions: \"Please use a single tool call to submit the solution.\" The typical format is to output a JSON with the tool call only. The platform expects a single tool call message.\n\nI need to output a single message with the tool call only, no other text. My previous response had a tool call but also had preceding explanation. The user says I didn't format my response correctly. So I need to output ONLY the tool call.\n\nThus I will produce a single tool call to submit_solution, containing the Python code.\n\nLet's double-check the code to ensure it's correct. I will include the code that reads input, processes it, and prints answer.\n\nPotential optimization: Use sys.stdin.buffer for speed. But the code above is fine.\n\nAlso note that in the code we are using dictionaries for groups; but we need to import sys. It's included.\n\nNow, respond with only the tool call in the proper JSON format.", "tool_calls": [{"type": "function", "id": "functions.submit_solution:1", "function": {"name": "", "arguments": "{\"python_code\": \"import sys\\n\\ndef solve():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    it = iter(data)\\n    n = int(next(it))\\n    point_set = set()\\n    groups = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\\n    for _ in range(n):\\n        x = int(next(it))\\n        y = int(next(it))\\n        point_set.add((x, y))\\n        parity = (x & 1, y & 1)\\n        groups[parity].append((x, y))\\n    ans = 0\\n    for group in groups.values():\\n        m = len(group)\\n        for i in range(m):\\n            xi, yi = group[i]\\n            for j in range(i + 1, m):\\n                xj, yj = group[j]\\n                # Since both points have the same parity, (xi + xj) and (yi + yj) are even.\\n                xm = (xi + xj) >> 1\\n                ym = (yi + yj) >> 1\\n                if (xm, ym) in point_set:\\n                    ans += 1\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"}"}}]}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "", "thinking": "The user is complaining that I'm not formatting my response correctly and that I should use a single tool call to submit the solution. The correct way is to call the `submit_solution` tool with the code as a string argument, which I did. But they still say it's not correct. Perhaps they don't want any additional text outside the tool call. The instructions say: \"Please use a single tool call to submit the solution. The script should read the input... Note that the solution would be run as is, so you must NOT print anything other than the expected output. Namely, do NOT use debug prints and do not write demos.\"\n\nThe \"submission\" tool is supposed to send the code. I wrote some messages before and after the tool call. The user likely wants me to output only the tool call, not any other text. The tool call should be the only content in the response. That is typical: just produce the tool call.\n\nThus I should respond with only a single tool call, no extra explanation or text before or after. The content inside the tool call should be the Python code.\n\nLet me try that.", "tool_calls": [{"type": "function", "id": "functions.submit_solution:2", "function": {"name": "", "arguments": "{\"python_code\": \"import sys\\n\\ndef solve():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    it = iter(data)\\n    n = int(next(it))\\n    point_set = set()\\n    groups = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\\n    for _ in range(n):\\n        x = int(next(it))\\n        y = int(next(it))\\n        point_set.add((x, y))\\n        parity = (x & 1, y & 1)\\n        groups[parity].append((x, y))\\n    ans = 0\\n    for group in groups.values():\\n        m = len(group)\\n        for i in range(m):\\n            xi, yi = group[i]\\n            for j in range(i + 1, m):\\n                xj, yj = group[j]\\n                xm = (xi + xj) >> 1\\n                ym = (yi + yj) >> 1\\n                if (xm, ym) in point_set:\\n                    ans += 1\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\\n\"}"}}]}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "", "thinking": "It appears the system expects a very specific format for the \"submit_solution\" tool call: a single tool call that contains just the python code. It complains that my response is not formatted correctly. Possibly I need to not include any other text or formatting, just the tool call with the code. The \"python_code\" field should contain the code. I should not include any extra commentary or explanation outside of the tool call. Let me try properly: just the tool call with the code and nothing else.", "tool_calls": [{"type": "function", "id": "functions.submit_solution:3", "function": {"name": "", "arguments": "{\"python_code\": \"import sys\\n\\ndef solve():\\n    data = sys.stdin.read().strip().split()\\n    if not data:\\n        return\\n    it = iter(data)\\n    n = int(next(it))\\n    point_set = set()\\n    groups = {(0, 0): [], (0, 1): [], (1, 0): [], (1, 1): []}\\n    for _ in range(n):\\n        x = int(next(it))\\n        y = int(next(it))\\n        point_set.add((x, y))\\n        parity = (x & 1, y & 1)\\n        groups[parity].append((x, y))\\n    ans = 0\\n    for group in groups.values():\\n        m = len(group)\\n        for i in range(m):\\n            xi, yi = group[i]\\n            for j in range(i + 1, m):\\n                xj, yj = group[j]\\n                xm = (xi + xj) >> 1\\n                ym = (yi + yj) >> 1\\n                if (xm, ym) in point_set:\\n                    ans += 1\\n    sys.stdout.write(str(ans))\\n\\nif __name__ == \\\"__main__\\\":\\n    solve()\"}"}}]}]