[{"role": "system", "content": "You are a very competent coder.<|im_end|><|im_system|>tool_declare<|im_middle|>[{\"function\":{\"description\":\"Call this tool to submit the solution python code.\",\"name\":\"submit_solution\",\"parameters\":{\"properties\":{\"python_code\":{\"type\":\"str\"}},\"required\":[\"python_code\"],\"type\":\"object\"}},\"type\":\"function\"}]"}, {"role": "user", "content": "Please solve the following programming problem. Please use tool calls to output the solution.\nThe script should read the input with the `input` function and print the output with the `print` function.\nNote that the solution would be run as is, so you must NOT print anything other than the expected output. Namely, do NOT use debug prints and do not write demos.\n\nTokitsukaze has a permutation $$$p$$$ of length $$$n$$$.\n\nLet's call a segment $$$[l,r]$$$ beautiful if there exist $$$i$$$ and $$$j$$$ satisfying $$$p_i \\cdot p_j = \\max\\{p_l, p_{l+1}, \\ldots, p_r \\}$$$, where $$$l \\leq i < j \\leq r$$$.\n\nNow Tokitsukaze has $$$q$$$ queries, in the $$$i$$$-th query she wants to know how many beautiful subsegments $$$[x,y]$$$ there are in the segment $$$[l_i,r_i]$$$ (i.\u00a0e. $$$l_i \\leq x \\leq y \\leq r_i$$$).\n\n\n\n"}, {"role": "assistant", "content": "<think>We need to solve this problem. Let's rewrite it:\n\nWe are given a permutation p of length n (1-indexed). A segment [l, r] (l <= r) is called \"beautiful\" if there exist indices i and j such that l <= i < j <= r and p_i * p_j = max(p[l..r]). Since it's a permutation, all values are distinct and in range [1, n].\n\nWe have q queries, each query giving a segment [l_i, r_i]; we need to output the number of beautiful subsegments [x, y] such that l_i <= x <= y <= r_i.\n\nSo we need to count number of beautiful intervals (subarrays) within a query interval.\n\nConstraints: Not given, but typical competitive programming problem: n up to maybe 2e5 or 3e5, q similar. We need O((n+q) sqrt n) perhaps, or O(n log n). Let's think.\n\nGiven a permutation p[1..n]. For each interval [l, r], let M = max(p[l..r]). Condition: there exist i<j in [l, r] such that p_i * p_j = M.\n\nWe need to count intervals where this holds.\n\nObservation: Since p is a permutation, each value appears exactly once. M must be product of two distinct elements in the interval: p_i * p_j = M with i < j. Since M <= n, both p_i and p_j are less than M (since they are distinct and multiplied to M). Also each element is at most n. For them to multiply to M, we need p_i and p_j to be factors of M. So we need both factors present in interval.\n\nThus the property depends on whether the interval contains two elements a and b such that a * b = M, and where M is also present (as maximum). Actually M is the maximum element in the interval, and also must have a*b = M with distinct positions. So M must be the product of two distinct numbers in the interval, and must be the maximum in that interval.\n\nGiven the permutation, each value appears at some position pos[value] = index.\n\nSo for each pair (a, b) with a < b and a * b <= n (since the product must be a value in permutation), we want to consider intervals where max = a*b = M, and both a, b appear, and M appears as max. Since M will be the max if there are no elements > M in the interval. So interval must include positions of a, b, and M, and not include any element > M (i.e., any element in (M, n]). Since M itself is max, the interval cannot contain any element > M.\n\nThus we can consider each triple (a, b, M = a*b), with a < b, a * b <= n. Let's denote positions pos[a], pos[b], pos[M]. Since it's permutation, they are distinct.\n\nDefine L = min(pos[a], pos[b], pos[M]), R = max(pos[a], pos[b], pos[M]).\n\nFor an interval to have max = M and include a,b,M, it must include [L,R] (i.e., L >= left bound, R <= right bound). Additionally, it must not contain any element > M. That means that the interval's left bound must be > the nearest position to the left of L of any element > M. Similarly for the right bound.\n\nMore concretely, for any element x > M, its position pos[x] cannot be inside interval. If there are elements > M outside [L,R], they restrict the allowed interval left/right.\n\nThus the set of intervals where max = M and includes a, b as the pair: the interval must be a subarray containing L..R but staying within the \"range free of >M\". This is essentially the maximal 'valid' interval around them where no >M elements appear.\n\nDefine left limit: the nearest position to the left of L that contains an element > M (or 0 if none). Let leftBound = that position + 1. Similarly, right limit: nearest position to the right of R containing an element > M (or n+1 if none). Let rightBound = that position - 1.\n\nThen any interval [l, r] satisfying leftBound <= l <= L and R <= r <= rightBound will have max = M (since all elements > M are outside), and includes a,b,M, thus is beautiful. Moreover, those intervals are exactly the beautiful intervals where the max=M and a,b are the witnessing pair.\n\nPotentially there could be multiple pairs (a,b) for same M (if M has multiple factor pairs). For instance, if M = 6, pairs (1,6) and (2,3). However note that a and b must be distinct and both less than M (since a,b < M). Also a and b must be distinct numbers.\n\nThus each beautiful interval may be counted multiple times if it contains multiple factor pairs? But definition requires existence of some pair; each interval only needs to be counted once. So we need to avoid double counting across multiple possible pairs. However we can handle by \"covering\" intervals via unique representation. For each interval we need to count it if there exists at least one pair. So we need to compute the set of intervals where any factor pair exists. This is a union over contributions for each factor pair.\n\nPotential approach: Process intervals in increasing order of max value M, compute contributions of new intervals that become beautiful due to M. Since M's are distinct values, intervals that have max = M may be added, but some intervals may have already been counted as beautiful due to a larger max? Wait larger max > M cannot be present in interval because M is max. So intervals with max = M are distinct from those with larger max. So intervals with max = M are not overlapping with intervals counted for larger M. However for each M, there could be multiple factor pairs; we need to ensure we count each interval only once per M (i.e., if it contains multiple pairs we should not count multiple times). That's doable: we can treat each interval's \"beauty\" due to existence of at least one pair; we can count intervals for M as the number of intervals covering L..R within bounds where there exists at least one pair among those present.\n\nBut we need to consider all pairs (a,b) such that a*b = M and positions satisfy constraints. For each M, we need to consider all factor pairs (a,b). Intervals where at least one of those pairs is present (with both a and b plus M). However intervals may contain multiple such pairs; we need to avoid double counting.\n\nSimplify: For each M, define the set of intervals that satisfy:\n\n- Contains pos[M].\n- Contains at least one pair (a,b) with a*b=M (a<b).\n- Contains no elements > M.\n\nOur goal: count distinct intervals across all M.\n\nThus we need to compute for each M, the union over factor pairs of the set of intervals defined by that pair (as earlier, an interval range defined by L,R and leftBound/rightBound). For each pair, we have a set of intervals (l,r) such that leftBound <= l <= min(pos[a],pos[b],pos[M]) and max(...) <= r <= rightBound.\n\nWe need to count the union cardinality over all factor pairs for the same M and across all M.\n\nA naive enumeration of all factor pairs for all M is O(n log n) maybe. Since n up to 2e5, we could consider for each M, iterate over its divisors a where a < M/a and a * (M / a) = M, but we need both a and M/a to be values in permutation (they are <= n). However if a > n? Since a <= M <= n. So pairs correspond to factor pairs of numbers <= n. We can precompute divisors for all M up to n. The total number of divisor pairs across all M is about n log n? Actually sum_{M=1}^n d(M) ~ n log n + (2\u03b3 - 1)n + o(n). So ~ n log n. That's okay for n=2e5 (~2e5*12=2.4 million). Manageable.\n\nThus we can iterate all factor pairs (a,b) with a*b = M <= n, and a<b (ensuring distinct). For each, we get positions of a,b,M.\n\nTherefore, we can compute contributions.\n\nBut we need to answer queries: number of beautiful intervals inside query interval [L_i,R_i].\n\nWe need to process offline perhaps using BIT (Fenwick) or segment tree to answer number of beautiful subsegments within each query rectangle.\n\nClassic technique: Represent each beautiful interval [l,r] as a point (l,r) in 2D plane (with l <= r). For a query [L,R], we need to count number of points such that L <= l <= r <= R. That's counting points in rectangle [L,R] x [L,R] with l <= r. That can be done by counting all points with l >= L and r <= R.\n\nWe can process points sorted by l descending or ascending and maintain BIT on r positions.\n\nStandard solution: sort intervals by l descending, then for each query (L,R), we count number of intervals with l >= L and r <= R. That can be answered as: iterate l from n down to 1, adding intervals whose l equals current index to BIT keyed by r (increment). Then for each query with left bound L, we query BIT up to R (prefix sum) to get number of intervals with l >= L and r <= R. Complexity O((#intervals + q) log n). However #intervals may be huge: number of beautiful intervals could be O(n^2). That is too large.\n\nThus we cannot enumerate all intervals.\n\nWe need to find a way to count them combinatorially.\n\nThe property depends on factor pairs and \"max element\". Perhaps the number of beautiful intervals is O(n log n) not O(n^2). Let's test: For each M, the intervals where max = M and contain a factor pair of M are essentially intervals that contain positions of M and of a factor pair, while not containing any >M elements. Since >M elements are bigger values, which are fewer as M increases.\n\nPotentially many intervals may be beautiful, but maybe not too many. Consider worst case: p is sorted ascending (1,2,...,n). Then each interval's max is its rightmost element. For a given M, M is at position M. The interval must include some pair (a,b) with a*b=M, and must not include any element > M. Since array is sorted, any interval that ends at M and includes positions of a and b (both less than M) will automatically not include >M because those would be on right. However could still include >M if we extend beyond M. But intervals must be <= right bound limited by nearest >M element to the right, which is at position M+1. So the right bound for intervals with max=M is M (can't go beyond M). Similarly left bound cannot go beyond leftmost >M? Actually >M to left also would be >M values on left side (positions >M index?). Since sorted ascending, values >M appear to the right only. So left bound can be any position <= min of positions of leftmost element in triplet. So many intervals.\n\nSo let's count intervals in sorted permutation p[i]=i. For each M, we need factor pairs a*b=M with a<b. The pair positions are a and b and M at position M. L = min(a,b,M) = maybe a (smallest factor), R = M. The interval can start anywhere from (previous >M left bound?) Since there is no >M to left, leftBound = 1. Right bound is M (since >M at M+1). So intervals are any [l, r] such that 1 <= l <= a (or min factor) maybe? Actually we need l <= L (triplet leftmost) and r >= R and also <= rightBound. Since R=M, r must be >= M and <= M => r=M. So r=M is forced. For l, we can pick any l <= L (i.e., <= a). So number of intervals with max=M = a (since l can be any from 1 to a). So we get sum over factor pairs of M of a where a is smaller factor. Since multiple factor pairs produce overlapping intervals maybe counted multiple times if M has multiple factor pairs; we need to avoid double counting intervals.\n\nBut sorted permutation example: M=6 has factor pairs (1,6) but 6 is M itself, we need a<b and a,b<M? Actually condition requires p_i * p_j = max = M. Since p_i and p_j are elements in interval; they cannot be M itself (product M*other > M). But could one of them be 1? Yes if a=1, b=M; product M. That needs b=M? Wait b=M? The equation a*b = M. If a=1, b=M, then b=M, which is the max element itself; but we require i<j and p_i * p_j = M. If p_j=M (the max), then product becomes p_i * M = M => p_i must be 1. So indeed it's allowed that one of the pair includes the max element itself (as factor 1). The condition doesn't forbid i or j being the position of the max element, because p_i * p_j = M, and max = M. If one of them equals M, then product includes M. This can only happen if other factor equals 1. That is allowed. So pair (1,M) works. Similarly for any M, pair (1,M) always works if the interval contains both 1 and M and M is max (which is true if no >M). However note that condition requires i < j, both positions inside interval. So pair (a,b) may include M as one factor; but a,b values are from the interval: they can be M itself. So factor pair (a,b) may be (1,M). (M, >M) can't because >M not present. Also (M, something >1) product >M.\n\nThus each M can have factor pairs where one factor is M and the other factor is 1. So we always have at least the pair (1, M). This suggests many intervals might be beautiful because containing 1 and M may be sufficient.\n\nBut does (1,M) correspond to i<j positions where p_i = 1 and p_j = M (or vice versa). Since interval includes both positions, and product = M*1 = M, it's okay. So for any interval where max=M and contains the position of 1 (pos[1]), it is beautiful (via pair (1,M)). But careful: if M=1? Then max=1, need product of two elements equal to 1. But permutation values are distinct; only element 1 itself exists. So you cannot have two distinct elements whose product = 1 because only 1*1 =1 but cannot have distinct positions with both values 1 (impossible). So M=1 cannot be beautiful (except maybe interval length >=2 includes 1 and something else? No product must equal 1; impossible). So we need M>1.\n\nSimilarly for each M>1, if the interval includes pos[1] and pos[M] and no larger elements, it's beautiful. So many intervals.\n\nThus counting all beautiful intervals may be large; maybe O(n^2) in worst case (sorted permutation). Indeed consider permutation ascending. For any interval [l, r], max = p[r] = r. The interval is beautiful iff it contains position of 1 (i.e., l <= pos[1] <= r). Because then we can use pair (1, max). pos[1] = 1. So any interval that includes position 1 is beautiful (since max >1). Also any interval that does not include position 1 may still be beautiful if it contains another factor pair of its max; but let's see.\n\nThus count beautiful intervals in ascending permutation: Number of intervals that include index 1 (pos[1]) = n (choose right endpoint r >=1 and left endpoint l <=1). Specifically left endpoint must be 1 (since l <= 1). l can be 1 only, r can be any from 1..n. So that's n intervals. Wait also intervals not containing 1 but still may be beautiful via other factor pairs. For instance, interval [2,3] with max=3, includes 1? No. It includes numbers 2 and 3. Check condition: Need i<j with product = max=3. Options: (1,3) not present; (3,1) same; maybe (1,3) not possible; (3, something else) leads product >3 except 1. So not possible. So [2,3] not beautiful. For interval [2,4], max=4, contains 2 and 4, maybe also 1? No. But pair (2,2) product=4 but need distinct positions; we cannot have two 2's. Pair (1,4) not present. So not beautiful. Interval [3,6], max=6, contains maybe 2 and 3? 2*3=6, both present, distinct, and max=6. Indeed interval [3,6] includes positions 3..6 includes values [3,4,5,6]; includes 2? No. But 2 not present. However a=2, b=3 product 6. The value 2 is not present; but we need both 2 and 3. So not. Actually need both a=2 and b=3; we have 3 present, need 2 not present. So not.\n\nThus intervals not containing 1 may still be beautiful if they include a factor pair of their max (both factors). Since max=r, the pair's factors a,b must be \u2264 r and both present somewhere between l..r. Because permutation is sorted, any factor pair (a,b) where both \u2264 r is present in the interval only if both a and b >= l as well (since interval includes all indices from l to r). Since permutation sorted includes all numbers between l and r. So for interval [l,r], the set includes all numbers from l..r. Thus existence of factor pair a,b with a*b=r means we need a,b in [l,r] and a*b=r. l can be greater than 1. So intervals like [2,6] includes numbers 2..6: includes 2 and 3; both multiply to 6, thus beautiful even though 1 not present. Good. So many intervals beyond those containing 1.\n\nThus the number of beautiful intervals can be O(n^2). For n=200k, this is impossible to enumerate.\n\nThus we need a smarter way to answer queries without enumerating intervals.\n\nObservation: Condition depends only on positions of values greater than M (restrict interval) and existence of a factor pair (including possibly 1). Maybe we can treat each interval's 'beauty' as satisfied if there exists a factor pair where both factors present and max is their product.\n\nSimplify: Let's define for each position of max value M, we need to find intervals where max = M and at least one factor pair (a,b) with a*b=M is present. In permutation, each value appears at some position pos[value].\n\nIf we precompute for each M, the \"nearest larger element\" positions to the left and right (elements > M). Let L_Bound[M] = nearest index left of pos[M] where value > M, plus 1. Let R_Bound[M] = nearest index right of pos[M] where value > M, minus 1. If none, use 1 and n respectively. Then any interval [l,r] with max=M must contain pos[M] and be contained within [L_Bound[M], R_Bound[M]] (i.e., L_Bound[M] <= l <= pos[M] <= r <= R_Bound[M]).\n\nNow, within this \"max M interval\", we need at least one factor pair (a,b). For each pair (a,b) such that a*b=M, we consider positions pos[a] and pos[b]. The interval must contain both positions, and still be inside bounds (i.e., not include any >M). However >M elements are exactly those that define L_Bound and R_Bound. Since those bounds are determined by nearest >M positions, any interval within the bounds automatically excludes all >M.\n\nThus for a given pair (a,b), the set of intervals that satisfy are those where left bound l can be any index in [L_Bound[M], min(pos[a], pos[b], pos[M])], and right bound r can be any index in [max(pos[a], pos[b], pos[M]), R_Bound[M]].\n\nBut that's not all: The interval must also contain both positions pos[a] and pos[b]; but l and r as defined ensure that.\n\nThus the intervals allowed for a specific pair are all intervals where l <= L_max = min(pos[a], pos[b], pos[M]), and r >= R_min = max(pos[a], pos[b], pos[M]), with bounds. So given l <= L_max, r >= R_min, obviously we need l <= r; note that L_max < R_min unless maybe some positions overlapping.\n\nThus the set of pairs (l,r) can be characterized as: l can range from lowL to L_max, r can range from R_min to highR, with lowL = L_Bound[M], highR = R_Bound[M]. So #intervals for this pair = (L_max - lowL + 1) * (highR - R_min + 1).\n\nBut this counts intervals that may overlap across multiple factor pairs for same M and also across different M. For each M, we need to count the total number of intervals where at least one factor pair holds. Since each M defines intervals distinct across M (they have different max), we can treat per M union problem.\n\nThus we can compute for each M, the set of intervals defined by factor pairs as rectangles defined by l in [lowL, L_max] and r in [R_min, highR]. The union area (or count of integer pairs (l,r) with l <= r? Actually any l in that range and any r in that range automatically ensures l <= r? Need to verify: Since lowL <= L_max, and R_min <= highR. However we must maintain l <= r. Since l <= L_max and r >= R_min. But could we have l > r? That would require L_max > R_min? Actually typical intervals: L_max is the minimum of the three positions; R_min is the maximum of the three positions. Since min <= max, L_max <= R_min. Because L_max = min(pos[a],pos[b],pos[M]), and R_min = max(...). So indeed L_max <= R_min. So any l <= L_max and r >= R_min will satisfy l <= L_max <= R_min <= r, thus l <= r automatically holds. So the interval count is product as above.\n\nThus each factor pair gives a rectangle of possible (l,r) pairs (with l on horizontal axis, r on vertical axis). Actually we need to count each (l,r) once even if multiple rectangles cover it.\n\nGoal: compute total number of integer pairs (l,r) (with 1 <= l <= r <= n) belonging to union of these rectangles across all M and all factor pairs of M. Then for queries, we need to count number of such intervals with l >= L_i and r <= R_i. That's a 2D dominance query: count number of points (l,r) where l >= L and r <= R. That's same as count of intervals whose left endpoint >= L and right endpoint <= R. That is a subset of intervals that are inside query.\n\nIf we could compute for each M a set of intervals as above but count them via combinatorial inclusion-exclusion or something to answer queries quickly, maybe we can precompute prefix sums. However number of intervals could be huge (maybe O(n^2)). So we need to compute counts for queries without enumerating intervals.\n\nIdea: Use offline queries with sweep line and segment tree but treat intervals as \"range add\" contributions, not individually. Since each factor pair defines a rectangle of intervals (l, r) where l in a range and r in a range. The contribution to queries can be decomposed: For each query [L,R], we want number of rectangles that contain a point (l,r) with l >= L and r <= R. That's like counting rectangles that intersect the lower-right quadrant defined by (L,R). Equivalent to counting rectangles where L_max >= L? Wait need careful.\n\nDefine rectangle: l \u2208 [lowL, L_max] and r \u2208 [R_min, highR]. For rectangle to contain a point satisfying l >= L and r <= R, we need L_max >= L (since l must be at least L, but we can pick l from [L, L_max] if L <= L_max). Also we need R_min <= R (since r can be at most R, must be at least R_min, so need R_min <= R). Additionally we need lowL <= L_max (always). Actually we also need existence of l and r satisfying both: choose l = max(L, lowL), as long as <= L_max; similarly choose r = min(R, highR) >= R_min. So rectangle contributes to query if and only if:\n\n- L <= L_max (so there exists an l >= L)\n- R >= R_min (so there exists an r <= R)\n- Also max(L, lowL) <= L_max and min(R, highR) >= R_min combine to true if L <= L_max and R >= R_min and also lowL <= L_max and R_min <= highR (always). But also we need that the selected l and r satisfy l <= r; but since L_max <= R_min (as they are min and max positions), picking l >= L and r <= R ensures l >= L and r <= R, but l <= L_max <= R_min <= r? Wait R_min <= r, and l <= L_max. Since L_max <= R_min, we have l <= L_max <= R_min <= r, thus l <= r holds automatically.\n\nThus rectangle contributes if:\nL <= L_max and R >= R_min.\n\nNote: no dependence on lowL, highR? Actually as long as L is not > L_max, there is some l >= L within the rectangle's l range because the rectangle's l range includes any l up to L_max and >= lowL. But if L > L_max, there is no allowed l >= L because l cannot exceed L_max. So condition L <= L_max is necessary.\n\nSimilarly, R >= R_min is necessary.\n\nThus each factor pair contributes a rectangle defined by two thresholds: left limit L_max, and right limit R_min. The query must have L <= L_max and R >= R_min. That's independent of lowL and highR (except they cannot violate, but they are automatically satisfied if lowL <= L_max and highR >= R_min, which is always true because lowL = L_Bound[M] <= pos[M] <= ... etc). Actually need to also consider L must be >= lowL? Since query interval's left bound L is inside [l_i, r_i], we count intervals where l >= L. If rectangle's l range is [lowL, L_max], then l must be >= L. So need L <= l \u2264 L_max, thus L must be <= L_max, and also L must be >= lowL? Wait l has to be >= L, but rectangle defines l can be any number >= lowL. If L > lowL, then we restrict l >= L (i.e., we take intersection). If lowL > L, then l >= lowL > L, still okay because l >= L, but the rectangle doesn't contain l in [L, lowL-1]; but those l values are not allowed anyway as they are less than lowL (outside rectangle). So for rectangle to contain some l satisfying l >= L, we need the intersection [max(L, lowL), L_max] to be non-empty, i.e., max(L, lowL) <= L_max. That's equivalent to L <= L_max and lowL <= L_max. Since lowL <= pos[M] <= L_max (L_max is among three positions, so >= lowL). So condition reduces to L <= L_max.\n\nThus rectangle's contribution to query depends only on L_max and R_min.\n\nSo each factor pair contributes a \"point\" (L_max, R_min) with weight +1? Actually each rectangle yields all pairs (l,r) where l in [lowL, L_max] and r in [R_min, highR]. But for query, we ask for intervals (l,r) that satisfy both l >= L and r <= R. The set of intervals contributed by rectangle can be seen as all (l,r) such that l <= L_max and r >= R_min (plus l >= lowL, r <= highR). If we consider counting intervals as points (l,r) in 2D plane, then each rectangle corresponds to a region (a set of points). However the condition for query to count any of those intervals is rectangle region intersects the query region (l >= L and r <= R). Actually we count intervals inside query. For each rectangle, the intervals that belong to query are those where l >= L and r <= R; i.e., we need to count points (l,r) that lie in intersection of rectangle with half-plane l >= L and r <= R. Each such point is a beautiful interval.\n\nWe need to compute total number of such points across all rectangles for each query.\n\nWe cannot enumerate points, but maybe we can compute contributions per rectangle as some function of (L,R) that can be aggregated via data structures.\n\nGiven a rectangle defined by l\u2208[lowL, L_max] and r\u2208[R_min, highR], the number of points (l,r) inside the rectangle that also satisfy l >= L and r <= R is:\n\n- l range: intersection of [lowL, L_max] with [L, n] (since l>=L) gives [max(L, lowL), L_max] if max(L, lowL) <= L_max else empty.\n- r range: intersection of [R_min, highR] with [1, R] gives [R_min, min(R, highR)] if R_min <= min(R, highR).\n\nSince for any l in that range and any r in that range, the point (l,r) is a beautiful interval (distinct). So the count contributed by rectangle to query is:\n\nif max(L, lowL) <= L_max and R_min <= min(R, highR):\n   cnt = (L_max - max(L, lowL) + 1) * (min(R, highR) - R_min + 1)\nelse 0.\n\nThus each rectangle contributes a product of two independent ranges. So we need to sum over rectangles.\n\nThis is similar to counting contributions of pairs (l,r) where intervals are formed by picking l from a left set and r from a right set defined per rectangle.\n\nObservation: For a given M, rectangles across factor pairs have same lowL= L_Bound[M] and same highR= R_Bound[M], but different L_max (min position of three) and R_min (max position of three). Because lowL and highR are determined solely by M (and the nearest greater elements). So each factor pair gives a rectangle of the form:\n\nl in [L_Bound[M], L_max_i]\nr in [R_min_i, R_Bound[M]]\n\nwhere L_max_i = min(pos[a_i], pos[b_i], pos[M]), R_min_i = max(pos[a_i], pos[b_i], pos[M]).\n\nThus each rectangle is defined by two thresholds (L_max_i,R_min_i). The rectangle basically includes all points with left endpoint at least L_Bound[M] and at most L_max_i, and right endpoint at least R_min_i and at most R_Bound[M].\n\nThus the union across rectangles for same M may have overlapping ranges. Counting contributions per query needs to consider union.\n\nBut per M, the left bound lowL is same for all rectangles: L_Bound[M]; similarly right bound highR same: R_Bound[M].\n\nThus we have a set of intervals (L_max_i, R_min_i) (maybe treat L_max as \"left limit threshold\"? Actually L_max_i is max allowed left; R_min_i is min allowed right). The set of beautiful intervals defined by M is the set of all pairs (l,r) such that there exists i with l \u2264 L_max_i and r \u2265 R_min_i, and also l \u2265 lowL, r \u2264 highR.\n\nThus we need to count the number of pairs (l,r) inside the outer rectangle [lowL, highR] for which there exists i such that l \u2264 L_max_i and r \u2265 R_min_i. That is analogous to a set of points (L_max_i,R_min_i) in the plane such that (l,r) is covered if l \u2264 L_max_i and r \u2265 R_min_i (i.e., (l,r) is in the upper-left quadrant of point (L_max_i,R_min_i)). The union of these coverage sets for all i.\n\nThus the set of covered points (l,r) inside the outer rectangle is the region under the upper envelope of these thresholds. Because for each l, we need r >= min possible? Let's analyze.\n\nGiven set of pairs (Lmax_i,Rmin_i). For a fixed left endpoint l (lowL \u2264 l \u2264 some max Lmax across all i), we consider all i such that Lmax_i >= l (since need l \u2264 Lmax_i). Among those i, the condition on r is r >= Rmin_i. So the minimal r that qualifies is the minimum over those Rmin_i? Wait: we need there exists i with r >= Rmin_i. So for given l, any r that is at least the minimum of those Rmin_i? Actually if r >= some Rmin_i, that i qualifies. So the set of allowable r is the union over i with Lmax_i >= l of intervals [Rmin_i, highR]. That's equal to [min_{i: Lmax_i >= l} Rmin_i, highR] (since any r greater than or equal to any Rmin_i qualifies). But is it min? Suppose Lmax_i >= l for multiple i with different Rmin_i values. If r is less than min(Rmin_i) then it's less than all Rmin_i => fails. If r >= min(Rmin_i), then there exists at least one i where r >= Rmin_i? Wait if r >= min(Rmin_i), does that guarantee r >= some Rmin_i? Since min(Rmin_i) is the smallest among them; if r >= that smallest, then r >= that one (the one achieving min). So yes, there is some i (the argmin) where r >= Rmin_i. So condition reduces to r >= minR(l), where minR(l) = min { Rmin_i | Lmax_i >= l }. So for each l, the allowable r range is [minR(l), highR].\n\nThus the region of beautiful intervals for M is defined by function f(l) = min { Rmin_i : Lmax_i >= l } for l \u2208 [lowL, max Lmax_i]. And also for l > max Lmax_i there is no i covering that left endpoint (since l > all Lmax_i). For those l, no beautiful intervals exist.\n\nThus the total number of beautiful intervals for M equals sum over l from lowL to maxL (where maxL = max_i Lmax_i) of (highR - f(l) + 1), assuming f(l) \u2264 highR. If f(l) > highR, count is zero.\n\nSimilarly, for queries we could compute contributions of each M to query (L,R). For a given query with L,R, we need count of intervals where left endpoint l >= L and right endpoint r <= R, that are beautiful overall across all M. Since each interval's max is unique, we can handle contributions per M independently; we can sum contributions per M to the query.\n\nThus the problem reduces to for each M, we need a data structure that can answer for any query (L,R) the number of pairs (l,r) inside rectangle lowL \u2264 l \u2264 maxL_i? Wait we cannot treat each M separately for each query as that would be O(n q).\n\nBut maybe we can process all queries offline using BIT/segment tree and sweeping left endpoint or right endpoint while maintaining contributions of intervals that are \"currently valid\". However contributions involve potentially O(n) intervals each with their own allowed range for l and r. However maybe we can compress down to O(n log n) events.\n\nLet's try to model the set of beautiful intervals in a way that can be efficiently queried. Equivalent to: For each left endpoint l, we can define the minimal right endpoint r_min(l) such that any interval [l, r] with r >= r_min(l) is beautiful (i.e., there exists some M and some factor pair etc). Actually across all M, an interval [l,r] is beautiful if max element of [l,r] is M and there exists factor pair etc. The max depends on the interval itself (max of interval). But perhaps we can define a predicate based on the maximum element M and left endpoint l. For each M and left endpoint l, there is a minimal right endpoint needed to have a beautiful interval with max=M: must be at least R_min_i for some factor pair where Lmax_i >= l.\n\nThus for each l, define the smallest r needed across all M such that an interval [l,r] is beautiful. However intervals with different max have different ways covering left endpoint. Actually when we consider global across all M, for a given left endpoint l, there could be multiple possible intervals with different max values M, each yields certain minimal right endpoints. For interval [l,r] to be beautiful, we need r >= min_M ( min_R_M(l) ), where min_R_M(l) is minimal right endpoint needed for that M given left l. Actually need existence of some M such that interval's max = M, includes appropriate factor pair. But interval's max is determined by max element in interval; if we consider a given left l and right r, the max is max(p[l..r]), not predetermined. So we can't arbitrarily pick M; it's the max of that interval. So we"}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "<think>The user wants me to solve a programming problem. The problem description is about counting \"beautiful subsegments\" in a permutation based on certain conditions.\n\nLet me restate the problem:\n- We have a permutation p of length n (1-indexed).\n- A segment [l, r] is beautiful if there exist i, j with l \u2264 i < j \u2264 r such that p_i * p_j = max(p_l, p_{l+1}, ..., p_r). Let M = max(p[l..r]).\n- We have q queries. For each query [l_i, r_i], we need to count the number of beautiful subsegments [x, y] such that l_i \u2264 x \u2264 y \u2264 r_i.\n\nWe need to write a Python program that reads input, solves the problem, and prints the answer. We cannot output debug prints or anything else.\n\nFirst, I need to understand the constraints. The problem statement doesn't give explicit limits, but typical competitive programming problems have n, q up to 2e5 or 3e5. The solution should be O((n+q) log n) or similar.\n\nKey challenges:\n1.  Counting beautiful intervals efficiently.\n2.  Answering queries about the number of beautiful intervals inside a query range.\n\n**Understanding \"beautiful\" intervals:**\n\nFor an interval [l, r], let M = max(p[l..r]).\nThe interval is beautiful if \u2203 i, j (i < j) in [l, r] such that p_i * p_j = M.\nSince p is a permutation, all values are distinct.\n\nImportant observation:\n- The condition p_i * p_j = M means that M must be the product of two distinct elements in the interval.\n- If M = 1, it's impossible because we need two distinct elements whose product is 1. So intervals with max=1 are never beautiful.\n- If M > 1, one simple way to be beautiful is if the interval contains both 1 and M, because 1 * M = M. This is a very common case.\n- More generally, for any factorization M = a * b with a < b and a, b < M, if the interval contains a, b, and M, it's beautiful (provided M is the max).\n\n**Structure of a beautiful interval:**\n\nLet M be the maximum value in the interval [l, r]. For the interval to be beautiful:\n1. It must contain the position of M: pos[M] \u2208 [l, r].\n2. It must contain positions i, j such that p_i * p_j = M.\n3. It must not contain any element greater than M. This means the interval [l, r] must be fully contained within the segment defined by the nearest greater elements to the left and right of pos[M].\n\nLet:\n- `pos[x]` be the index of value x in the permutation.\n- `L_greater[M]` = the nearest index < pos[M] with p[index] > M (or 0 if none).\n- `R_greater[M]` = the nearest index > pos[M] with p[index] > M (or n+1 if none).\n- Any beautiful interval with max M must satisfy: `L_greater[M] + 1 \u2264 l \u2264 pos[M]` and `pos[M] \u2264 r \u2264 R_greater[M] - 1`.\n\nLet's denote:\n- `L_bound[M] = L_greater[M] + 1`\n- `R_bound[M] = R_greater[M] - 1`\n\nNow, for a specific factor pair (a, b) where a * b = M and a < b (allowing a=1):\n- Let positions be `pos[a]`, `pos[b]`, `pos[M]`.\n- For an interval [l, r] to be beautiful via this pair:\n  - It must contain all three positions: `l \u2264 min(pos[a], pos[b], pos[M])` and `r \u2265 max(pos[a], pos[b], pos[M])`.\n  - It must be within `[L_bound[M], R_bound[M]]`.\n\nThis defines a **rectangle** of valid `(l, r)` pairs:\n- `l \u2208 [L_bound[M], L_max]` where `L_max = min(pos[a], pos[b], pos[M])`\n- `r \u2208 [R_min, R_bound[M]]` where `R_min = max(pos[a], pos[b], pos[M])`\n\nAny `(l, r)` in this rectangle corresponds to a beautiful interval where max=M and the pair (a, b) witnesses it.\n\n**Problem Reduction:**\n\nThe set of all beautiful intervals is the union of such rectangles over all M > 1 and over all factor pairs (a, b) of M.\n\nA query `[L_q, R_q]` asks for the number of beautiful intervals `[l, r]` such that `L_q \u2264 l` and `r \u2264 R_q`.\n\nThis is a 2D range counting problem: count points `(l, r)` (with `l \u2264 r`) that belong to the union of these rectangles and fall into the query region defined by `l \u2265 L_q` and `r \u2264 R_q`.\n\n**Key Insight for Efficient Counting:**\n\nThe total number of rectangles can be large (O(n log n)), but the structure of the union might be simpler.\n\nConsider a fixed M. All rectangles for M share the same `L_bound[M]` and `R_bound[M]`. For each rectangle i, we have thresholds `(L_max_i, R_min_i)`. An interval `[l, r]` is beautiful for this M if:\n- `L_bound[M] \u2264 l \u2264 min_{i s.t. L_max_i \u2265 l} R_min_i` ... No, that's not right.\n\nLet's fix `l`. Let `S(l) = {i | L_max_i \u2265 l}`. The interval `[l, r]` is beautiful if there exists an `i \u2208 S(l)` such that `r \u2265 R_min_i`. This is equivalent to `r \u2265 min_{i \u2208 S(l)} R_min_i`.\n\nSo for a fixed `l`, the minimum required `r` is `f_M(l) = min{R_min_i | L_max_i \u2265 l}`.\nThe set of beautiful intervals for this M is: `{ (l, r) | L_bound[M] \u2264 l \u2264 max(L_max_i) and r \u2265 f_M(l) }`.\n\nThis is like a staircase shape. Counting points under this staircase is a classic problem that can be solved with sorting and a Fenwick/BIT tree.\n\n**Alternative Approach: Sweepline on `l`**\n\nInstead of generating intervals `(l, r)`, we can process events sorted by `l` and maintain a data structure on `r`.\n\nFor each beautiful interval `[l, r]`, it's counted in a query `[L_q, R_q]` if `l \u2265 L_q` and `r \u2264 R_q`. This means we want to count intervals whose left endpoint is *to the right* of `L_q` and right endpoint is *to the left* of `R_q`.\n\nLet's re-index: define `l' = n - l + 1`. Then the condition `l \u2265 L_q` becomes `l' \u2264 n - L_q + 1`. The problem becomes counting points `(l', r)` in a \"prefix\" region: `l' \u2264 something` and `r \u2264 something`. This can be answered with a BIT/segment tree in 2D.\n\nBut we still need to *generate* the beautiful intervals or their contributions in a way that can be aggregated.\n\n**The \"Contribution\" Trick:**\n\nEach rectangle `[L_bound, L_max] \u00d7 [R_min, R_bound]` contributes `(L_max - L_bound + 1) * (R_bound - R_min + 1)` beautiful intervals. For a query `[L_q, R_q]`, the contribution from this rectangle is:\n\n`max(0, L_max - max(L_q, L_bound) + 1) * max(0, min(R_q, R_bound) - R_min + 1)`\n\nThis means we need to sum this product over all rectangles. This looks like a 2D range query where each rectangle has a weight that depends on its `L_max` and `R_min`.\n\nThis is complex. However, we can linearize the product by fixing one side. For example, for a fixed `l`, the set of intervals starting at `l` is beautiful if their `r` is greater than some threshold that depends on `l`.\n\n**A More Direct Approach:**\n\nLet's analyze the structure of beautiful intervals differently.\n\nAn interval `[l, r]` is beautiful if its maximum `M = max(p[l..r])` can be written as `p_i * p_j` with `i, j \u2208 [l, r]`.\n\nConsider the position of the maximum, `pos[M]`. The interval must contain `pos[M]`.\n\nConsider the set of values `S = {p[l], ..., p[r]}`.\n\nIf `1 \u2208 S`, then `M = M * 1`, so the interval is beautiful (unless `M=1`). So any interval containing `1` and with `max > 1` is beautiful.\n\nIf `1 \u2209 S`, we need another factor pair. Let `a` be the smallest element in `S` (excluding 1). Then `M` must be divisible by `a`. Let `b = M / a`. We need `b \u2208 S` and `a < b`.\n\nThis suggests that for each value `M`, the beautiful intervals with max `M` are those that contain `M` and contain a factor pair `(a, b)` of `M`.\n\nThe number of factor pairs for each `M` is small (its number of divisors). The total number of factor pairs across all `M` is `O(n log n)`.\n\n**The Plan:**\n\n1.  **Preprocess:**\n    - Read `n`, permutation `p` (1-indexed).\n    - Compute `pos[x]` for all `x`.\n    - Compute `L_bound[x]` and `R_bound[x]` for all `x` using a monotonic stack or iterating sorted by value. (We need nearest greater element to left/right).\n    - For each value `M` from `2` to `n`:\n        - Let `L_M = L_bound[M]`, `R_M = R_bound[M]`.\n        - Find all factor pairs `(a, b)` of `M` where `a < b` and `a, b` are values in the permutation (which is always true if `a, b \u2264 n`).\n        - For each pair `(a, b)`:\n            - Let `L_max = min(pos[a], pos[b], pos[M])`.\n            - Let `R_min = max(pos[a], pos[b], pos[M])`.\n            - **If** `L_max >= L_M` and `R_min <= R_M` (the pair \"fits\" inside the bounds):\n                - This pair defines a set of beautiful intervals: all `[l, r]` with `l \u2208 [L_M, L_max]` and `r \u2208 [R_min, R_M]`.\n                - We can treat this as an \"event\" that contributes to queries.\n\n2. **Answering Queries:**\n    A query `[L_q, R_q]` asks for the number of beautiful intervals `[l, r]` such that `L_q \u2264 l` and `r \u2264 R_q`.\n\n    Consider a beautiful interval `[l, r]` that comes from a specific pair `(a, b)` for max `M`. It satisfies:\n    - `l \u2265 L_M`\n    - `r \u2264 R_M`\n    - `l \u2264 L_max`\n    - `r \u2265 R_min`\n\n    So for a query, the interval `[l, r]` is counted if `L_q \u2264 l` and `r \u2264 R_q`.\n\n    The condition for the *existence* of such an `l, r` for a given pair `(a, b)` and query `[L_q, R_q]` is:\n    - `L_q \u2264 L_max` (so we can pick `l`)\n    - `R_min \u2264 R_q` (so we can pick `r`)\n\n    The number of such intervals contributed by this specific pair is:\n    `max(0, L_max - max(L_q, L_M) + 1) * max(0, min(R_q, R_M) - R_min + 1)`\n\n    This is still complex to sum over all pairs.\n\n**Let's rethink the counting from the perspective of the interval's left and right endpoints.**\n\nDefine a beautiful interval `[l, r]` by its left endpoint `l` and right endpoint `r`. The query asks for `l \u2265 L_q` and `r \u2264 R_q`.\n\nThis is a standard **offline 2D counting** problem if we can generate all beautiful intervals as points `(l, r)`. But there can be `O(n^2)` intervals, so we cannot generate them all.\n\nWe need to represent the *set* of beautiful intervals implicitly.\n\n**The \"Staircase\" Representation (Revisited):**\n\nFor each `M`, the beautiful intervals are defined by a staircase function `f_M(l)` as described before. The total set of beautiful intervals is the union of these staircases across all `M`.\n\nFor a fixed `l`, let `R_min(l)` be the minimum `r` such that `[l, r]` is beautiful. If no such `r` exists, let `R_min(l) = \u221e`.\n\nThen, the number of beautiful intervals `[l, r]` with `l \u2265 L_q` and `r \u2264 R_q` is:\n`\u03a3_{l=L_q}^{n} max(0, R_q - R_min(l) + 1)`\n\nThis is if we can compute `R_min(l)` efficiently for all `l`.\nIf we had `R_min(l)` for all `l`, we could answer a query in `O(log n)` using a Fenwick tree that stores prefix sums of counts and sums of `R_min(l)`.\n\nBut how to compute `R_min(l)`?\n`R_min(l)` is the minimum `R_min` among *all* rectangles (across all `M`) that cover `l`.\n\nRecall a rectangle for `(M, a, b)` is:\n`l \u2208 [L_M, L_max]`\n`r \u2208 [R_min, R_M]`\n\nFor a given `l`, a rectangle *contributes* to `R_min(l)` if `L_M \u2264 l \u2264 L_max`.\nIf it contributes, it imposes a lower bound on `r`: `r \u2265 R_min`.\n\nSo, `R_min(l) = min { R_min | \u2203 M, a, b: M = a*b, L_M \u2264 l \u2264 L_max(M, a, b) }`.\n\nThis looks like we can process `l` from `n` down to `1`. As we decrease `l`, more rectangles become \"active\" (i.e., their `l` range starts to cover the current `l`). For each rectangle `[L_M, L_max] \u00d7 [R_min, R_M]`, when we are at a point `l` in its range, it contributes the constraint `r \u2265 R_min`.\n\nWe want to find, for each `l`, the *minimum* such `R_min` among active rectangles.\n\nThis is a range update problem! For each rectangle, for all `l` in `[L_M, L_max]`, we want to update:\n`R_min(l) = min(R_min(l), R_min)`.\n\nWe can process `l` from `n` down to `1`. We maintain a segment tree that supports **range minimum updates** (or rather, point queries after range min assignments) and **point queries**.\n- Initially, `R_min(l) = \u221e` for all `l`.\n- For each unique value `R_min`, we want to update the range `[L_M, L_max]` to `min(current_value, R_min)`.\n\nAfter processing all rectangles, we will have `R_min(l)` for each `l`.\n\nBut there are `O(n log n)` rectangles. Doing `O(n log n)` range-min updates on a segment tree is feasible (`O((n log n) log n)`). However, we need to be careful about the complexity. `n = 200k`, `log n \u2248 18`, `n log n \u2248 3.6M`. `3.6M * log n \u2248 65M`, which is okay in Python if optimized.\n\n**Wait, there's a catch.**\n- `L_M = L_bound[M]` depends on `M`.\n- `L_max = min(pos[a], pos[b], pos[M])`.\n- `R_min = max(pos[a], pos[b], pos[M])`.\n- `R_M = R_bound[M]`.\n\nThe rectangle is defined by `l \u2208 [L_bound[M], L_max]` and `r \u2208 [R_min, R_bound[M]]`.\n\nThe condition for the interval to be beautiful is that `l` is in `[L_bound[M], L_max]` and `r` is in `[R_min, R_bound[M]]`.\n\nIf we fix `l`, the minimum `r` that makes `[l, r]` beautiful is:\n`min_{M, (a,b) : L_bound[M] \u2264 l \u2264 L_max(M,a,b)} R_min(M, a, b)`.\n\nSo, for each `M` and each factor pair `(a, b)`, we want to perform:\nFor all `l` in `[L_bound[M], L_max]`, update `R_min(l) = min(R_min(l), R_min)`.\n\nThis is a **range-min update**.\nWe can process all rectangles, collect them, and for each rectangle `[L, R]` (where `L = L_bound[M]`, `R = L_max`) with value `val = R_min`, we do `seg_tree.range_min_update(L, R, val)`.\n\nA segment tree can support range-min updates and point queries. Standard segment tree with lazy propagation can do this. Each node stores the current minimum value for its segment. A lazy value can be propagated to children.\n\n**After we have `R_min(l)` for all `l`**, what does a query `[L_q, R_q]` ask for?\n\nFor each `l` such that `L_q \u2264 l \u2264 R_q`, beautiful intervals starting at `l` have right endpoint `r` from `R_min(l)` to `R_q` (if `R_min(l) \u2264 R_q`).\n\nThe total count is:\n`\u03a3_{l=L_q}^{R_q} max(0, R_q - R_min(l) + 1)`\n\nLet `cnt(l) = number of beautiful intervals starting at l`. This depends on the query's right endpoint `R_q`. Let `R_min(l)` be the *global* minimum right endpoint needed for beauty.\n\nIf `[l, r]` is beautiful and `r \u2264 R_q`, then `[l, R_q]` is also beautiful? No, that's not true. If `[l, r]` is beautiful, it doesn't mean `[l, r+1]` is beautiful because the max might change or a factor might be lost.\n\nSo the formula `\u03a3 max(0, R_q - R_min(l) + 1)` is **WRONG**.\n\nExample: `p = [1, 2, 3]`. `pos[1]=1, pos[2]=2, pos[3]=3`.\n- Beautiful intervals:\n - `[1,2]`: max=2, contains 1. Beautiful.\n - `[1,3]`: max=3, contains 1. Beautiful.\n - `[2,3]`: max=3, does NOT contain 1. Does NOT contain (1,3) pair. 3=3*1 (no 1). No other pair. **NOT beautiful**.\n\nLet's compute `R_min(l)`:\n- `l=1`: intervals are `[1,1]` (max=1, not beautiful), `[1,2]` (beautiful), `[1,3]` (beautiful). `R_min(1) = 2`.\n- `l=2`: intervals are `[2,2]` (max=2, not beautiful), `[2,3]` (not beautiful). `R_min(2) = \u221e`.\n- `l=3`: interval `[3,3]` (max=3, not beautiful). `R_min(3) = \u221e`.\n\nNow query `[L=2, R=3]`. The beautiful interval is `[1,2]` and `[1,3]`. But `[2,3]` is not. So the answer is 0.\nMy formula: `\u03a3_{l=2}^{3} max(0, R_q - R_min(l) + 1)`\n- `l=2`: `max(0, 3 - \u221e + 1) = 0`\n- `l=3`: `max(0, 3 - \u221e + 1) = 0`\nTotal = 0. Correct for this case.\n\nQuery `[L=1, R=2]`. Beautiful intervals: `[1,2]`.\nMy formula: `\u03a3_{l=1}^{2} max(0, R_q - R_min(l) + 1)`\n- `l=1`: `max(0, 2 - 2 + 1) = 1`\n- `l=2`: `max(0, 2 - \u221e + 1) = 0`\nTotal = 1. Correct.\n\nQuery `[L=1, R=3]`. Beautiful intervals: `[1,2]`, `[1,3]`.\nmy formula: `\u03a3_{l=1}^{3} max(0, R_q - R_min(l) + 1)`\n- `l=1`: `max(0, 3 - 2 + 1) = 2`\n- `l=2`: `max(0, 3 - \u221e + 1) = 0`\n- `l=3`: `max(0, 3 - \u221e + 1) = 0`\nTotal = 2. Correct.\n\nIt seems the formula works! Let's double-check the logic.\n`R_min(l)` is the *minimum* right endpoint `r` such that `[l, r]` is beautiful.\nIf `[l, r]` is beautiful, then `[l, r']` is also beautiful for any `r' \u2265 r` *as long as the max remains M and the factor pair remains inside*.\n\n**CRITICAL FLAW:** `R_min(l)` might not be monotonic with `r`. The max can change.\nConsider `p = [4, 1, 2, 3]`. `n=4`.\n`pos[1]=2, pos[2]=3, pos[3]=4, pos[4]=1`.\n- Intervals:\n - `[1,1]`: max=4. Contains 1? No. Factor pairs? No. Not beautiful. (4 is max, needs pair, none)\n - `[1,2]`: max=4. Contains 1? Yes. **Beautiful**.\n - `[1,3]`: max=4. Contains 1? Yes. **Beautiful**.\n - `[1,4]`: max=4. Contains 1? Yes. **Beautiful**.\n\n- `[2,2]`: max=1. Not beautiful.\n- `[2,3]`: max=2. Contains 1? Yes. **Beautiful**.\n- `[2,4]`: max=3. Contains 1? Yes. **Beautiful**.\n\n- `[3,3]`: max=2. No 1. Not beautiful.\n- `[3,4]`: max=3. No 1. Not beautiful (needs 1 or (1,3) etc).\n\n- `[4,4]`: max=3. No 1. Not beautiful.\n\n`R_min(1) = 2` (from `[1,2]`). Queries:\n- `[1,2]`: `[1,2]` is beautiful. Formula: `l=1: max(0, 2-2+1)=1`. Total 1. OK.\n- `[1,3]`: Beautiful: `[1,2]`, `[1,3]`. Formula: `l=1: max(0, 3-2+1)=2`. Total 2. OK.\n- `[1,4]`: Beautiful: `[1,2]`, `[1,3]`, `[1,4]`. Formula: `l=1: max(0, 4-2+1)=3`. Total 3. OK.\n\n`R_min(2) = 3` (from `[2,3]`). Queries:\n- `[2,3]`: Beautiful: `[2,3]`. Formula: `l=2: max(0, 3-3+1)=1`. Total 1. OK.\n- `[2,4]`: Beautiful: `[2,3]`, `[2,4]`. Formula: `l=2: max(0, 4-3+1)=2`. Total 2. OK.\n\n`R_min(3) = \u221e`. `R_min(4) = \u221e`.\n\nThe formula `\u03a3_{l=L_q}^{R_q} max(0, R_q - R_min(l) + 1)` seems to correctly count the number of beautiful intervals `[l, r]` such that `L_q \u2264 l \u2264 r \u2264 R_q`.\n\n**Why is this formula correct?**\nFor a fixed `l`, let `S_l = {r | [l, r] is beautiful}`.\n`R_min(l) = min(S_l)` if `S_l` is non-empty, else `\u221e`.\nThe set of beautiful intervals starting at `l` that also satisfy `r \u2264 R_q` is `{r \u2208 S_l | r \u2264 R_q}`.\nIf `R_min(l) > R_q`, this set is empty, count is 0.\nIf `R_min(l) \u2264 R_q`, is the set exactly `{R_min(l), R_min(l)+1, ..., R_q}`?\n\n**THIS IS THE CRUCIAL ASSUMPTION.** Is `S_l` always a contiguous prefix `{R_min(l), R_min(l)+1, ...}`? Let's test.\n\nConsider `p = [2, 3, 1, 6]`. `n=4`.\n`pos[1]=3, pos[2]=1, pos[3]=2, pos[4]=? none, pos[5]=? none, pos[6]=4`.\nIntervals:\n- `[1,1]`: max=2, no 1, no pair. Not B.\n- `[1,2]`: max=3, no 1, no (1,3). Not B. (3=1*3, no 1)\n- `[1,3]`: max=3, has 1. **B**.\n- `[1,4]`: max=6, has 1. **B**. Also (2,3) -> 6. **B**.\n\n- `[2,2]`: max=3, not B.\n- `[2,3]`: max=3, has 1. **B**.\n- `[2,4]`: max=6, has 1. **B**. (2,3) inside? No, pos[2]=1. But 1 is inside. **B**.\n\n- `[3,3]`: max=1, not B.\n- `[3,4]`: max=6, has 1. **B**. (needs (2,3) but doesn't have 2, has 1). **B**.\n\n- `[4,4]`: max=6, no 1, no pair. Not B.\n\n`R_min(1) = 3`. `S_1 = {3, 4}`. **Contiguous**. OK.\n`R_min(2) = 3`. `S_2 = {3, 4}`. **Contiguous**. OK.\n`R_min(3) = 4`. `S_3 = {4}`. **Contiguous**. OK.\n\nIt seems `S_l` is indeed a contiguous suffix starting from `R_min(l)`. Let's try to reason why.\n\n**Proof attempt:**\nLet `r \u2208 S_l`, so `[l, r]` is beautiful with max `M`.\nLet `r' > r`. Then `[l, r']` contains `[l, r]`. Its max is `M' \u2265 M`.\n- If `M' = M`, then the same factor pair `(i, j)` still works (it's still in the interval), so `[l, r']` is beautiful.\n- If `M' > M`, then `M'` is a new element. The interval `[l, r']` now has a larger max `M'`. Does the previous factor pair still work? `p_i * p_j = M \u2260 M'`. So we need a *new* factor pair for `M'`. The existence of this new pair is not guaranteed.\n\n**COUNTEREXAMPLE** to contiguity:\n`p = [... , M, ... , a, ... , b, ...]` where M = a*b.\nConsider `l` that includes `a` and `b` but *not* `M`. Then `[l, r]` is not beautiful until `r` reaches `M`.\nSo `S_l` might be `{r | r \u2265 pos[M]}`. This is contiguous.\n\nConsider `l` that includes `M` but not `a, b`. Then `[l, r]` is not beautiful until `r` reaches the other factor.\nSo `S_l` might be `{r | r \u2265 max(pos[a], pos[b])}`. Contiguous.\n\nConsider `l` that includes `M, a` but not `b`. Not beautiful until `b` is included. Contiguous.\n\nIt seems `S_l` is always of the form `{r | r \u2265 some_threshold}`. Let's formalize.\n\nFor a fixed `l`, let `U(l)` be the set of values that appear in the suffix starting at `l`: `{p[l], p[l+1], ..., p[n]}`.\nFor any `r \u2265 l`, the interval `[l, r]` is beautiful iff `max(p[l..r])` has a factor pair within the set of *positions* `{p[l], ..., p[r]}`.\n\nThis is getting messy. Let's trust the formula `\u03a3 max(0, R_q - R_min(l) + 1)` for now, as it's a common pattern in such problems (e.g., counting subarrays with property P, where for each left endpoint we find the minimal right endpoint). If it's wrong, the whole approach fails.\n\n**Let's proceed with this plan:**\n\n1.  **Compute `R_min[l]` for all `l = 1..n`.**\n    - `R_min[l]` = minimum `r` such that `[l, r]` is beautiful, or `n+1` if none.\n2.  **Answer queries offline.**\n    - Query `i` asks for `ans_i = \u03a3_{l=L_i}^{R_i} max(0, R_i - R_min[l] + 1)`.\n    - This can be rewritten as:\n      `ans_i = \u03a3_{l=L_i}^{R_i} (R_i + 1) * [R_min[l] \u2264 R_i] - \u03a3_{l=L_i}^{R_i} R_min[l] * [R_min[l] \u2264 R_i]`\n    - Let `cnt(l, R_i) = 1` if `R_min[l] \u2264 R_i` else `0`.\n    - `ans_i = (R_i + 1) * \u03a3_{l=L_i}^{R_i} cnt(l, R_i) - \u03a3_{l=L_i}^{R_i} R_min[l] * cnt(l, R_i)`.\n    - We need to answer for each query `[L, R]`:\n        - `C(R) = |{l \u2208 [L, R] : R_min[l] \u2264 R}|`\n        - `S(R) = \u03a3_{l\u2208[L,R], R_min[l]\u2264R} R_min[l]`\n    - Then `ans = (R + 1) * C(R) - S(R)`.\n\n    This is a 2D range query: points are `(l, R_min[l])`. Query is rectangle `[L, R]` \u00d7 `(-\u221e, R]`.\n    Standard offline solution: sort points by `R_min[l]`, sort queries by `R`, use a Fenwick tree on the `l` axis.\n\n3.  **Algorithm:**\n    - **Step 1: Compute `pos`, `L_bound`, `R_bound`.**\n        - `pos[p[i]] = i`.\n        - Process values `M = n` down to `1`.\n        - When processing `M`, use a Fenwick tree or segment tree to find nearest greater element to left/right. Or simpler: sort positions of values > M and find neighbors. This is O(n log n) per M, too slow.\n        - **Better:** Use a balanced BST (like `sortedcontainers` or a custom treap) or a Union-Find structure. Standard trick: iterate `i` from 1 to `n`, maintain a DSU of \"active\" positions where values are > current M. Not trivial.\n        - **Even Better:** Iterate values `M` from `n` down to `1` and *activate* their positions. To find `L_bound[M]` and `R_bound[M]`, we need the closest *active* position to the left and right of `pos[M]`. We can maintain a `prev` and `next` array, and use a structure to find them efficiently (like a `bisect` on a sorted list of active positions). `bisect` on a list is O(log n) per query. Total O(n log n), which is fine (`2e5 * log 2e5`).\n\n    - **Step 2: Generate Rectangles.**\n        - For each `M` from `2` to `n` (or `n` to `2`, order doesn't matter):\n            - `L_M = L_bound[M]`, `R_M = R_bound[M]`.\n            - Iterate over divisors `a` of `M` such that `a < M` and `b = M / a` is integer and `a < b`.\n            - For each `(a, b)`:\n                - `L_max = min(pos[a], pos[b], pos[M])`.\n                - `R_min = max(pos[a], pos[b], pos[M])`.\n                - **Crucial Check:** We need `L_M \u2264 L_max` and `R_min \u2264 R_M` for the rectangle to be non-empty AND for the interval to have max `M`. Wait, `L_M \u2264 L_max` ensures left bound is valid. `R_min \u2264 R_M` ensures right bound is valid.\n                - If these hold, this rectangle `[L_M, L_max]` x `[R_min, R_M]` defines beautiful intervals.\n                - For our `R_min[l]` update, this rectangle tells us that for all `l \u2208 [L_M, L_max]`, the minimum right endpoint is at most `R_min`. So we want to perform:\n                  `for l in [L_M, L_max]: R_min[l] = min(R_min[l], R_min)`.\n\n    - **Step 3: Range Min Updates.**\n        - Initialize `R_min[l] = n+1` for all `l`.\n        - We will process updates. Instead of processing per rectangle, we can process per **value** `R_min`. For each possible right endpoint `r_val`, collect all intervals `[L, R]` that need to be updated with `r_val`.\n        - Sort these **update intervals** by their `R_min` value.\n        - Use a segment tree with lazy propagation that supports **range min assignment**: `seg.range_chmin(L, R, val)`.\n        - After processing all updates, query `R_min[l] = seg.point_query(l)`.\n        - Complexity: If we process updates sorted by `val`, we might do `O(U log n)` where `U` is number of updates (rectangles). `U = O(n log n)`. So `O(n log^2 n)` total. This might be heavy but passable (`2e5 * 18 * 18 \u2248 65M` operations).\n\n        - **Alternative for Range Min:** Use a **sweep line from right to left**.\n            - Process `l` from `n` down to `1`.\n            - At step `l`, we add *all* rectangles `[L, R]` where `L = l`.\n            - We maintain a data structure (like a multiset) of the corresponding `R_min` values.\n            - The current `R_min[l]` would be `min(multiset)`.\n            - This is **not correct** because `L` is a *range*. A rectangle `[L_M, L_max]` affects `l=5` if `L_M \u2264 5 \u2264 L_max`. This is not captured by a simple sweep where `L` is fixed.\n\n        - **Back to Segment Tree with lazy `chmin`**. This is the right tool.\n            - Node stores `min_val` for the segment.\n            - Lazy stores a `pending_min` value to push down.\n            - `update(node, l, r, ql, qr, val)`: if `qr < l or r < ql`: return. If `ql <= l and r <= qr`: `tree[node] = min(tree[node], val); lazy[node] = min(lazy[node], val); return.\n            - This is O(log n) per update.\n\n    - **Step 4: Answer Queries Offline.**\n        - Build array of points: `(index=l, value=R_min[l])`.\n        - For each query `i` with `[L_i, R_i]`:\n            - We need to sum over `l \u2208 [L_i, R_i]` where `R_min[l] \u2264 R_i`.\n            - This is a 2D offline query: points `(l, R_min[l])`.\n            - Sort points by `R_min` value.\n            - Sort queries by `R_i`.\n            - Use a Fenwick tree `bit` over indices `1..n`.\n            - For each query with `R = R_i`:\n                - While point pointer `p < n` and `R_min[point] \u2264 R_i`:\n                    - `bit.add(point.index, 1)`\n                    - `point_pointer++`\n                - `C(R_i) = bit.sum(R_i) - bit.sum(L_i - 1)` (number of points"}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}, {"role": "assistant", "content": "<think>We need to produce a final answer in the form of a Python program solution. We cannot output anything else; we must use the tool call to submit the solution.\n\nThe thinking was cut off. The user is asking to format the response correctly with a single tool call.\n\nThus I must produce a final answer: a Python solution code. The solution must be correct, handle the problem, and not produce debug prints.\n\nLet's write a solution based on the derived algorithm:\n\n1. Input n, permutation p (1-indexed).\n2. Compute pos[x] = index of value x.\n3. Compute L_bound and R_bound for each value M using a sorted list of positions of processed larger values.\n   Simpler: iterate M from n down to 1, maintain a sorted list of positions of values > M, use bisect to find neighbors. Complexity O(n log n).\n4. Initialize R_min[l] = n+1 for all l.\n5. Use a segment tree that supports range chmin updates and point queries to compute R_min.\n   For each M from 2..n:\n     L_M = L_bound[M], R_M = R_bound[M]\n     Iterate over divisors a of M where a < M:\n       b = M // a\n       if a >= b: continue (to avoid pairs where a=b, but we also need a<b)\n       if a * b != M: continue\n       Compute L_max = min(pos[a], pos[b], pos[M])\n       Compute R_min = max(pos[a], pos[b], pos[M])\n       If L_M <= L_max and R_min <= R_M:\n         seg.update(L_M, L_max, R_min)  # range min update\n\n   After processing all M, query the segment tree for each l: R_min[l] = seg.point_query(l).\n\n6. Prepare queries: we need to answer q queries offline.\n   For each query i: (L, R). The answer is sum_{l=L to R} max(0, R - R_min[l] + 1). This can be computed using two BITs:\n   For each l where R_min[l] <= n, we treat it as a point (l, R_min[l]).\n   To answer query (L, R):\n      Count points with l in [L,R] and value <= R: C = count_{l in [L,R]} [R_min[l] <= R]\n      Sum of their values: S = sum_{l in [L,R], R_min[l] <= R} R_min[l]\n      Answer = (R + 1) * C - S\n\n   This is a standard 2D offline query: sort points by value and BIT over index l.\n\n   Implementation: \n   - Create list of points: (R_min[l], l) for each l where R_min[l] <= n. If R_min[l] = n+1, ignore, as it contributes 0.\n   - Sort points by R_min.\n   - Sort queries by R.\n   - Use BIT (Fenwick) for counts (bit_cnt) and another BIT for sums (bit_sum).\n   - Iterate queries sorted by R, add points with R_min <= R to BITs.\n   - Answer query: C = bit_cnt.range_sum(L,R), S = bit_sum.range_sum(L,R). Answer = (R+1)*C - S.\n\nMake sure to use 1-indexed BIT.\n\nComplexities:\n- O(n log n) for L_bound, R_bound.\n- O(total_divisors * log n) for rectangle updates = O(n log n log n).\n- O((n+q) log n) for answering queries with BIT.\n\nPotential pitfalls:\n- Factor pairs: need to iterate a from 1 to sqrt(M). Ensure a < b to avoid double counting and ensure distinct indices (a != b). But wait, the problem says i < j, p_i != p_j. If a = b, then p_i = p_j, which is impossible in a permutation. So we must have a != b. So we only consider a < b.\n- a=1 is allowed. So pair (1, M) is valid. For M>1, this always works if pos[1] is in the interval.\n- However, when iterating divisors, a can be 1. So we will generate pair (1, M).\n- For pair (1, M): pos[1] and pos[M]. L_max = min(pos[1], pos[M]), R_min = max(pos[1], pos[M]). This rectangle covers intervals containing both 1 and M. Update range [L_bound[M], L_max] with R_min.\n\nEdge cases: M might be large, but factorization loop O(sqrt(M)) per M is too heavy. Need to precompute divisors for all M using sieve-like approach: for i from 1..n, for multiples j = i*2, i*3, ... <= n, add i as divisor. Complexity O(n log n). This will give all divisors a where a < j. For each divisor a of M, b = M / a. We need a < b. So we need to generate pairs (a, M/a) where a < M/a.\n\nAlternative: just loop a from 1..sqrt(M) using divmod for each M. Sum_{M=1..n} sqrt(M) ~ n^{3/2} which is too heavy for n=200k (approx 9e9). So we need to precompute divisors.\n\nBetter: for i from 1..n, for j = 2*i, 3*i, ..., k*i <= n, let M = j, a = i, b = M/a = j/i. Since i < j, a < b automatically for i < j. This will generate each pair (a,b) exactly once for each M. Complexity O(n log n).\n\nThus the loop:\nfor a in range(1, n+1):\n    for M in range(2*a, n+1, a): # M = a * b, b >= 2\n        b = M // a\n        if a >= b: continue # can happen if a*a == M? Need a<b, so skip if a >= b\n        # Process pair (a,b) for M.\n\nThis will generate all pairs (a,b) with a*b <= n, a < b.\n\nNow inside the loop we need to compute L_max = min(pos[a], pos[M], pos[b]), R_min = max(...), and boundaries L_bound[M] and R_bound[M]. So we need L_bound and R_bound arrays for all M precomputed.\n\nThus algorithm steps in order:\n\n- Read n, p.\n- Build pos[1..n].\n- Compute L_bound[M], R_bound[M] for M from n down to 1.\n   Implementation: maintain sorted list \"active\" of positions of values > M.\n   For M from n down to 1:\n      idx = pos[M]\n      Use bisect to find left neighbor >=? Actually we need nearest > M. Since active contains positions of values > M (since we processed higher values), we can just bisect.\n      Using bisect_left: find insertion point idx.\n      left_pos = active[idx-1] if idx>0 else 0.\n      right_pos = active[idx] if idx < len(active) else n+1.\n      L_bound[M] = left_pos+1, R_bound[M] = right_pos-1.\n      Then insert idx into active list (or use a balanced BST, but Python's list insert is O(n) => O(n^2) worst-case; need better). We can use `bisect` on `array` and `insort` is O(n). Too slow for n=2e5.\n\nBetter way: we can compute L_bound and R_bound using a segment tree or DSU. Or we can process from high to low values and use a Union-Find structure to find nearest neighbors. Or use a BIT: we need predecessor/successor queries. We can use `bisect` on a sorted list if we build it offline by processing positions in order of decreasing value and inserting them into a structure that supports O(log n) predecessor/successor. Python's `bisect` on a list combined with `insort` is O(n) per insertion. Not good.\n\nAlternative: We can compute L_bound and R_bound for each *position* i, i.e., find nearest greater element to left and right using a monotonic stack. This is classic O(n): iterate i from 1..n, maintain stack of decreasing values. But we need bounds for each *value M* based on its position pos[M]. That's equivalent: for each index i, compute nearest index j < i with p[j] > p[i] (left greater) and nearest index j > i with p[j] > p[i] (right greater). This gives bounds for the value at position i. Since p is a permutation, each value M is at unique position pos[M]. So we can compute L_greater[i] and R_greater[i] for each index i, then for value M = p[i], we have L_bound[M] = L_greater[i] + 1, R_bound[M] = R_greater[i] - 1. This is O(n) with a monotonic stack.\n\nYes! So:\n- Compute arrays leftGreaterPos[i] and rightGreaterPos[i] for each position i.\n   leftGreaterPos[i] = index of nearest element to the left of i with value > p[i]; 0 if none.\n   rightGreaterPos[i] = index of nearest element to the right of i with value > p[i]; n+1 if none.\n- Then for value M = p[i], we have L_bound[M] = leftGreaterPos[i] + 1, R_bound[M] = rightGreaterPos[i] - 1.\n\nThat's O(n).\n\nNow we can proceed.\n\nImplementation details:\n\nSegment Tree for range min updates:\n- Need class SegmentTree with size n.\n- tree: list of size 4*n, initialize to INF (n+1).\n- lazy: list of size 4*n, initialize to INF.\n- update(node, l, r, ql, qr, val): apply range chmin.\n- query(node, l, r, idx): point query.\n\nBut we have many updates: O(n log n) of them, each O(log n). This yields O(n log^2 n) ~ 2e5 * 300 \u2248 60 million, which might be borderline but likely okay in Python if optimized. We'll try to implement iteratively to avoid recursion overhead.\n\nAlternative: use a simpler approach: For each l, we want min R_min. We can process rectangles by grouping by L_bound? Not easy.\n\nSegment tree with lazy chmin is classic for range minimum updates. However, we must implement carefully: after updates, we need to query each point. We can do a final DFS to push down all lazy and read values: O(n).\n\nSimplify: use a difference array of min values? Not applicable because updates are over ranges with min.\n\nSegment Tree implementation plan:\n- Use an array `seg` of size 4*n, initialized to INF.\n- Use an array `lazy` of size 4*n, initialized to INF.\n- update(ql, qr, val): recursively update.\n- After all updates, do a final traversal to compute final values: `finalize(node, l, r, cur_min)` where cur_min is the min from ancestors. At leaf, `R_min[l] = min(seg[node], cur_min)`.\n\nBut easier: We can just query each point: for l in 1..n: R_min[l] = seg.point_query(l). That's O(n log n) extra, overall O(n log^2 n). That's fine.\n\nBut we must ensure recursion depth is not too high (n=2e5, recursion depth O(log n) ~ 18). OK.\n\nAlternatively, we can use an iterative segment tree (size power of 2). But range chmin on iterative seg tree is non-trivial.\n\nLet's stick with recursive.\n\nImplementation details for update:\n```python\ndef update(node, l, r, ql, qr, val):\n    if qr < l or r < ql: return\n    if ql <= l and r <= qr:\n        tree[node] = min(tree[node], val)\n        lazy[node] = min(lazy[node], val)\n        return\n    push(node)\n    mid = (l+r)//2\n    update(node*2, l, mid, ql, qr, val)\n    update(node*2+1, mid+1, r, ql, qr, val)\n    tree[node] = min(tree[node*2], tree[node*2+1])\n```\nBut this is not quite right for chmin lazy: if lazy[node] is set, we should push it down before recursing. Actually we can just push before recursing:\n```python\ndef push(node):\n    if lazy[node] != INF:\n        tree[node*2] = min(tree[node*2], lazy[node])\n        lazy[node*2] = min(lazy[node*2], lazy[node])\n        tree[node*2+1] = min(tree[node*2+1], lazy[node])\n        lazy[node*2+1] = min(lazy[node*2+1], lazy[node])\n        lazy[node] = INF\n```\nThis is a standard \"segment tree beats\" style but simpler: we only have chmin updates, so we can store the max? No, we need min. This works: tree[node] stores the current min for the segment. lazy[node] stores a pending min to apply.\n\nBut note: after children are updated, tree[node] = min(tree[left], tree[right]) might become incorrect if parent lazy is still there. Since we push before recurse, children will be correct. After recursion, we recompute: tree[node] = min(tree[left], tree[right]).\n\nBut we also need to consider that tree[node] itself may have been updated directly via lazy. When we push, we set children min, but tree[node] also should remain? Actually after push, we clear lazy[node] (set to INF), but tree[node] already reflects the min. The children now also reflect it. So recomputing after recursion is fine.\n\nAlternatively, we can avoid recomputing by not storing anything in tree[node] for lazy nodes, just store lazy. But simpler to use library segment tree? We'll implement our own.\n\nSimplify: We can implement a segment tree that only supports range chmin and final point queries. We can process updates and then do a final DFS to collect values.\n\nAnother alternative: We can process updates sorted by value, using a DSU \"union-find next\" structure to skip already set positions, similar to painting intervals. However, since updates are chmin (taking min), not assignment, this is tricky.\n\nGiven time constraints, we will implement the segment tree.\n\n**Optimization:**\n- The number of updates (rectangles) may be up to ~ n log n \u2248 2-3 million. Each update does O(log n) recursion calls. 3M * 18 \u2248 54M function calls. This might be heavy in Python. We need to micro-opt.\n\nWe can try to compress the updates: For each M, we might have many pairs. But note that for a fixed M, all updates for that M have the same left bound L_bound[M]. So for each M, we want to update intervals [L_bound[M], L_max_i] with R_min_i.\n\nWe could group by L_bound, but that doesn't reduce complexity.\n\nAnother idea: Instead of segment tree, we can use an array `best[l]` initially INF, and for each M process all its pairs and update `best[l] = min(best[l], R_min)` for l in [L_bound[M], L_max_i] using a loop. That's O(total_interval_length) which could be O(n^2) worst-case. Not good.\n\nThus segment tree is appropriate.\n\nPotential recursion depth might be high for Python recursion limit. Use sys.setrecursionlimit(1<<25) or iterative.\n\nLet's code iterative segment tree approach:\n\nWe can use a segment tree where each node holds a \"lazy\" value, and we push down on query. For point query, we start from root and traverse down, taking min of all lazy values along path.\n\nSegment tree size = 1.\nRepresent node index i (0-indexed for array). For point query:\n```python\ndef point_query(idx):\n    # idx is 0-indexed for [0, n-1] segment representing positions 1..n\n    res = INF\n    i = 1 # root index (if tree is 1-indexed)\n    l = 0\n    r = size-1\n    while l != r:\n        res = min(res, lazy[i])\n        mid = (l+r)//2\n        if idx <= mid:\n            i = i*2\n            r = mid\n        else:\n            i = i*2+1\n            l = mid+1\n    # at leaf\n    return min(res, lazy[i])\n```\nBut we need to handle updates: range chmin. Lazy is just a value to propagate to children when needed. For range update, we can use recursion as it's simpler.\n\nGiven the time, I'll use recursion with sys.setrecursionlimit.\n\n**Fenwick Tree for queries:**\nWe need two BITs: one for counts, one for sums.\nBIT sum = prefix sum. Range sum = sum(R) - sum(L-1).\n\n**Implementation Steps:**\n\n```python\nimport sys\nimport bisect\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    p = [0] * (n + 1)\n    for i in range(1, n + 1):\n        p[i] = int(next(it))\n    q = int(next(it))\n    queries = []\n    for idx in range(q):\n        l = int(next(it))\n        r = int(next(it))\n        queries.append((l, r, idx))\n\n    # pos array\n    pos = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pos[p[i]] = i\n\n    # Compute L_bound and R_bound for values using monotonic stack\n    # leftGreaterPos[i]: nearest index to left with value > p[i]\n    leftGreaterIdx = [0] * (n + 1)\n    stack = []\n    for i in range(1, n + 1):\n        while stack and p[stack[-1]] < p[i]:\n            stack.pop()\n        if stack:\n            leftGreaterIdx[i] = stack[-1]\n        else:\n            leftGreaterIdx[i] = 0\n        stack.append(i)\n\n    # rightGreaterIdx[i]: nearest index to right with value > p[i]\n    rightGreaterIdx = [n + 1] * (n + 2)\n    stack = []\n    for i in range(n, 0, -1):\n        while stack and p[stack[-1]] < p[i]:\n            stack.pop()\n        if stack:\n            rightGreaterIdx[i] = stack[-1]\n        else:\n            rightGreaterIdx[i] = n + 1\n        stack.append(i)\n\n    # L_bound[M], R_bound[M]\n    L_bound = [0] * (n + 1)\n    R_bound = [0] * (n + 1)\n    for M in range(1, n + 1):\n        i = pos[M]\n        L_bound[M] = leftGreaterIdx[i] + 1\n        R_bound[M] = rightGreaterIdx[i] - 1\n\n    # Segment Tree for range min update\n    INF = n + 2\n    size = 1\n    while size < n:\n        size <<= 1\n    seg = [INF] * (2 * size)\n    lazy = [INF] * (2 * size)\n\n    def apply(node, value):\n        seg[node] = min(seg[node], value)\n        lazy[node] = min(lazy[node], value)\n\n    def push(node):\n        if lazy[node] != INF:\n            apply(node * 2, lazy[node])\n            apply(node * 2 + 1, lazy[node])\n            lazy[node] = INF\n\n    def update(node, nl, nr, ql, qr, val):\n        if qr < nl or nr < ql:\n            return\n        if ql <= nl and nr <= qr:\n            apply(node, val)\n            return\n        push(node)\n        mid = (nl + nr) // 2\n        update(node * 2, nl, mid, ql, qr, val)\n        update(node * 2 + 1, mid + 1, nr, ql, qr, val)\n        # seg[node] = min(seg[node * 2], seg[node * 2 + 1]) # not needed if only point queries\n\n    def point_query(idx):\n        node = 1\n        nl = 0\n        nr = size - 1\n        res = INF\n        while nl != nr:\n            res = min(res, lazy[node])\n            mid = (nl + nr) // 2\n            if idx <= mid:\n                node = node * 2\n                nr = mid\n            else:\n                node = node * 2 + 1\n                nl = mid + 1\n        res = min(res, lazy[node])\n        return res\n\n    # Process rectangles\n    # For each a, iterate multiples M = a*k (k>=2)\n    for a in range(1, n + 1):\n        M = a * 2\n        while M <= n:\n            b = M // a\n            if a < b:\n                M_val = M\n                # positions\n                pos_a = pos[a]\n                pos_b = pos[b]\n                pos_M = pos[M_val]\n                L_max = pos_a\n                if pos_b < L_max: L_max = pos_b\n                if pos_M < L_max: L_max = pos_M\n                R_min = pos_a\n                if pos_b > R_min: R_min = pos_b\n                if pos_M > R_min: R_min = pos_M\n\n                L_M = L_bound[M_val]\n                R_M = R_bound[M_val]\n\n                if L_M <= L_max and R_min <= R_M:\n                    # update range [L_M, L_max] with R_min\n                    # convert to 0-indexed for segment tree\n                    l0 = L_M - 1\n                    r0 = L_max - 1\n                    update(1, 0, size - 1, l0, r0, R_min)\n            M += a\n\n    # Compute R_min array\n    R_min = [n + 1] * (n + 1)  # 1-indexed\n    for l in range(1, n + 1):\n        R_min[l] = point_query(l - 1)  # point_query uses 0-index\n\n    # Prepare data for offline queries: points (l, R_min[l])\n    points = [(l, R_min[l]) for l in range(1, n + 1) if R_min[l] <= n]\n    # Sort points by R_min value\n    points.sort(key=lambda x: x[1])\n\n    # Sort queries by R\n    sorted_queries = [(r, l, idx) for (l, r, idx) in queries]\n    sorted_queries.sort()\n    # Actually need to sort by R, but need L and idx too.\n    sorted_queries_by_R = sorted(queries, key=lambda x: x[1])  # sort by r\n\n    # BIT classes\n    class BIT:\n        def __init__(self, n):\n            self.n = n\n            self.bit = [0] * (n + 1)\n        def add(self, idx, val):\n            while idx <= self.n:\n                self.bit[idx] += val\n                idx += idx & -idx\n        def sum(self, idx):\n            s = 0\n            while idx > 0:\n                s += self.bit[idx]\n                idx -= idx & -idx\n            return s\n        def range_sum(self, l, r):\n            return self.sum(r) - self.sum(l - 1)\n\n    bit_cnt = BIT(n)\n    bit_sum = BIT(n)\n\n    ans = [0] * q\n    p_ptr = 0\n    for R_q, L_q, idx in sorted_queries_by_R:\n        while p_ptr < len(points) and points[p_ptr][1] <= R_q:\n            l_val = points[p_ptr][0]\n            r_val = points[p_ptr][1]\n            bit_cnt.add(l_val, 1)\n            bit_sum.add(l_val, r_val)\n            p_ptr += 1\n        C = bit_cnt.range_sum(L_q, R_q)\n        S = bit_sum.range_sum(L_q, R_q)\n        ans[idx] = (R_q + 1) * C - S\n\n    # Output answers in original order\n    out = '\\n'.join(str(x) for x in ans)\n    sys.stdout.write(out)\n\nif __name__ == \"__main__\":\n    solve()\n```\n\nThis is a complete solution. Let's test on small examples mentally.\n\nBut we need to verify that for each value M, we correctly iterate pairs and compute L_max and R_min correctly.\n\nNote: The loop `M = a * 2` then `M += a` steps through multiples of a. For each M, b = M // a is integer. Since a < b is required to avoid duplicates and ensure distinct elements, we must check a < b. For M = a * a (square), a = b, which violates distinctness. So `if a < b` correctly skips these. For M = a * (a+1), it's fine.\n\nAlso, need to ensure we process M from 2..n.\n\nTesting with a small example: n=3, p=[1,2,3].\npos[1]=1, pos[2]=2, pos[3]=3.\n\nCompute left/right greater:\ni=1: p1=1, stack empty -> leftGreater=0. stack=[1]\ni=2: p2=2, pop p1=1 (<2), stack empty -> leftGreater=0. stack=[2]\ni=3: p3=3, pop p2=2 (<3), stack empty -> leftGreater=0. stack=[3]\nSo leftGreaterIdx = [0,0,0,0] for i=1..3.\n\nrightGreater:\ni=3: stack empty -> rightGreater=4. stack=[3]\ni=2: pop p3=3 (>2)? No, p3=3 > 2, so while not popped. Wait while stack and p[stack[-1]] < p[i] is false (3<2 false). So rightGreater[2]=3 (index of 3). stack=[2,3]? Actually push i=2 after.\n   Let's compute correctly: while stack and p[stack[-1]] < p[i]: pop. At i=3, stack empty -> rightGreater[3]=4, stack=[3]. At i=2, p[3]=3 > p[2]=2, condition false, so rightGreater[2]=3 (stack[-1]). Then push i=2: stack=[2,3]. \ni=1: p[2]=2 > p[1]=1, so rightGreater[1]=2. stack=[1,2,3].\n\nSo rightGreaterIdx = [0,2,3,4] for i=1..3.\n\nThus L_bound and R_bound:\nM=1: pos=1, L=0+1=1, R=2-1=1.\nM=2: pos=2, L=0+1=1, R=3-1=2.\nM=3: pos=3, L=0+1=1, R=4-1=3.\n\nNow rectangles:\na=1: M goes 2,3.\n  M=2 (a=1,b=2):\n    pos_a=1, pos_b=2, pos_M=2. L_max = min(1,2,2)=1. R_min = max(1,2,2)=2.\n    L_bound[2]=1, R_bound[2]=2. Check: L_M=1 <= L_max=1, R_min=2 <= R_M=2. OK.\n    Update range [1,1] with val=2.\n  M=3 (a=1,b=3):\n    pos_a=1, pos_b=3, pos_M=3. L_max=1, R_min=3.\n    L_bound[3]=1, R_bound[3]=3. Check: 1<=1, 3<=3 OK.\n    Update [1,1] with val=3.\n\na=2: M=4 (skip > n)\na=3: M=6 (skip)\n\nNow segment tree: update [1,1] to min=2, then update [1,1] to min=3. So final R_min[1] = min(2,3) = 2.\nR_min[2] = INF, R_min[3] = INF.\n\nSo R_min = [inf, 2, inf, inf] (1-indexed).\n\nPoints: (1,2) only.\n\nQueries: Suppose q=1 ask [1,3].\nSorted by R: query R=3. Points ptr: add (1,2). C=1, S=2. ans = (3+1)*1 - 2 = 2.\nLet's enumerate beautiful intervals:\n[1,2]: max=2, contains 1,2. Beautiful.\n[1,3]: max=3, contains 1,3. Beautiful.\n[2,3]: max=3, contains 2,3 but not 1. No other pair. Not beautiful.\nTotal = 2. OK.\n\nQuery [2,3]:\nans = (3+1)*0 - 0 = 0. Since C=0 because R_min[2] is inf, R_min[3] is inf. True, no beautiful intervals start at 2 or 3.\n\nWorks.\n\nNow test with previous example: n=4, p=[1,2,3,4] (sorted).\npos = [0,1,2,3,4].\nCompute L/R bounds: Since increasing, no greater to left, all greater to right.\nleftGreater all 0. rightGreater: for i=1, rightGreater=2; i=2->3; i=3->4; i=4->5.\nL_bound: M=1:1, M=2:1, M=3:1, M=4:1.\nR_bound: M=1:1, M=2:2, M=3:3, M=4:4.\n\nRectangles:\na=1:\n  M=2: pos1=1, pos2=2, pos_M=2. L_max=1, R_min=2. Update [1,1] with 2.\n  M=3: pos1=1, pos3=3, pos_M=3. L_max=1, R_min=3. Update [1,1] with 3.\n  M=4: pos1=1, pos4=4, pos_M=4. L_max=1, R_min=4. Update [1,1] with 4.\na=2:\n  M=4: a=2,b=2? a<b false. So skip? Actually need a<b. So (2,2) not allowed. So no pair for 4 except (1,4). That's okay.\n\nSo R_min[1] = min(2,3,4) = 2. Others INF.\n\nPoints: (1,2) only.\nSo any beautiful interval must start at 1? Let's enumerate:\n[1,1] max=1 not beautiful (needs pair).\n[1,2]: max=2, has 1,2. Beautiful.\n[1,3]: max=3, has 1,3. Beautiful.\n[1,4]: max=4, has 1,4. Beautiful.\n[2,3]: max=3, no 1, no pair. Not beautiful.\n[2,4]: max=4, no 1, no pair (2*2=4 but need distinct). Not beautiful.\n[3,4]: max=4, no 1, no pair (2*2? no). Not beautiful.\nSo only intervals starting at 1 are beautiful: total 3. Our model: R_min[1]=2, R_min[2]=inf, etc.\n\nQuery [1,4]: C=1 (l=1), S=2. ans=(4+1)*1 - 2 = 3. OK.\nQuery [2,4]: C=0, ans=0. OK.\n\nNow test with p = [2,3,1,6] from earlier (n=4).\npos[1]=3, pos[2]=1, pos[3]=2, pos[4]=?, pos[5]=?, pos[6]=4.\n\nCompute left/right greater:\np: [2,3,1,6]\ni=1: val=2, stack empty -> leftGreater=0. stack=[1]\ni=2: val=3, pop 2<3 -> stack empty -> leftGreater=0. stack=[2]\ni=3: val=1, stack top val=3 >1 -> leftGreater=2. stack=[2,3]\ni=4: val=6, pop 1<6, pop 3<6, pop 2<6 -> stack empty -> leftGreater=0. stack=[4]\nleftGreaterIdx = [0,0,0,2,0]\n\nrightGreater:\ni=4: val=6, stack empty -> rightGreater=5. stack=[4]\ni=3: val=1, stack top val=6>1 -> rightGreater=4. stack=[3,4]\ni=2: val=3, stack top val=1<3 -> pop. now stack top val=6>3 -> rightGreater=4. stack=[2,3,4]? Wait after popping 3, stack is [4]. Then 6>3 so rightGreater=4. push 2 -> [2,4].\ni=1: val=2, stack top val=3>2 -> rightGreater=2. stack=[1,2,4].\nrightGreaterIdx = [0,?]. Let's compute properly:\nInitialize rightGreater = [n+1]*(n+1)\nstack = []\nfor i in range(n,0,-1):\n    while stack and p[stack[-1]] < p[i]: stack.pop()\n    if stack: rightGreater[i] = stack[-1]\n    else: rightGreater[i] = n+1\n    stack.append(i)\n\ni=4: p4=6, stack=[], rightGreater[4]=5, stack=[4]\ni=3: p3=1, while stack and p[4] < 1? false. rightGreater[3]=4, stack=[3,4]\ni=2: p2=3, while stack and p[3] < 3? p3=1<3 -> pop (stack becomes [4]). while stack and p[4] < 3? p4=6<3? false. rightGreater[2]=4, stack=[2,4]\ni=1: p1=2, while stack and p[2] < 2? p2=3<2? false. rightGreater[1]=2, stack=[1,2,4]\n\nSo rightGreaterIdx = [0,2,4,4,5]\n\nNow L_bound and R_bound:\nM=1 (pos=3): L= leftGreater[3]+1 = 2+1=3, R= rightGreater[3]-1 = 4-1=3.\nM=2 (pos=1): L=0+1=1, R= rightGreater[1]-1 = 2-1=1.\nM=3 (pos=2): L=0+1=1, R= rightGreater[2]-1 = 4-1=3.\nM=4 (pos=?? none) skip\nM=5 (none)\nM=6 (pos=4): L=leftGreater[4]+1 = 0+1=1, R=rightGreater[4]-1 = 5-1=4.\n\nL_bound = [0,3,1,1, - , -, 1] (index by value)\nR_bound = [0,3,1,3, - , -, 4]\n\nNow rectangles:\na=1:\n  M=2 (a=1,b=2):\n    pos_a=3, pos_b=1, pos_M=1. L_max = min(3,1,1) = 1. R_min = max(3,1,1) = 3.\n    L_bound[2]=1, R_bound[2]=1. Check: L_M=1 <= L_max=1 OK. R_min=3 <= R_M=1? **FALSE**. So this rectangle is invalid! Because the pair (1,2) extends beyond R_bound[2] (which is 1). This is because M=2's max allowed right bound is 1 due to element 3 being greater than 2 at position 2. Indeed, pos[2]=1, pos[3]=2 > p[1]. So any interval containing pos[2] and pos[1] cannot have max 2 if pos[3] is included. But the interval [1,3] includes pos[3], so max is 3, not 2. So such intervals should not be counted as beautiful for M=2 but might be for M=3. This matches our check: we only count intervals where max=M. So the rectangle must be clipped by R_bound[M].\n\nGood.\n\nSo update only if R_min <= R_bound[M].\n\nContinuing:\n  M=3 (a=1,b=3):\n    pos_a=3, pos_b=2, pos_M=2. L_max = min(3,2,2"}, {"role": "user", "content": "You did not format your response correctly.\nPlease use a single tool call to submit the solution.\n"}]